# 订单簿价差异常分析

## 正常情况下的价差

根据实际交易界面截图，**正常情况下订单簿价差只有几美分（1-6分）**：

### UP (YES) 方向
- Best Ask: 0.0500
- Best Bid: 0.0400
- **价差 = 0.0100 = 1分** ✅

### DOWN (NO) 方向
- Best Ask: 0.9600
- Best Bid: 0.9500
- **价差 = 0.0100 = 1分** ✅

## 日志中的异常情况

日志显示的数据：
```
YES bid=0.0100 ask=0.9900
NO bid=0.0100 ask=0.9900
```

### 价差计算
- **YES价差** = YES的ask(0.99) - YES的bid(0.01) = **0.98 = 98分** ❌
- **NO价差** = NO的ask(0.99) - NO的bid(0.01) = **0.98 = 98分** ❌

**这远超正常的1-6分价差，明显异常！**

## 可能的原因

### 1. REST API 返回了错误的数据
- 订单簿可能为空，但API返回了默认值（0.01 和 0.99）
- 或者API返回了错误的市场数据

### 2. 订单簿在那个时刻确实流动性极差
- 市场刚开盘或即将收盘
- 市场流动性枯竭
- 但这种情况比较少见

### 3. 数据解析问题
- REST API返回的数据格式可能有问题
- 解析逻辑可能没有正确处理空订单簿的情况

## 代码检查

### GetTopOfBook 函数逻辑

```go
// internal/services/trading_orders.go:375-387
parseTop := func(book *types.OrderBookSummary) (bid, ask domain.Price, e error) {
    var bestBid, bestAsk float64
    if book != nil && len(book.Bids) > 0 {
        bestBid, _ = strconv.ParseFloat(book.Bids[0].Price, 64)
    }
    if book != nil && len(book.Asks) > 0 {
        bestAsk, _ = strconv.ParseFloat(book.Asks[0].Price, 64)
    }
    if bestBid <= 0 || bestAsk <= 0 {
        return domain.Price{}, domain.Price{}, fmt.Errorf("incomplete book: bid=%.6f ask=%.6f", bestBid, bestAsk)
    }
    return domain.PriceFromDecimal(bestBid), domain.PriceFromDecimal(bestAsk), nil
}
```

**问题：**
- 如果 `book.Bids` 或 `book.Asks` 为空，`bestBid` 和 `bestAsk` 会保持为 0
- 代码会检查 `bestBid <= 0 || bestAsk <= 0`，应该返回错误
- 但日志显示返回了 `bid=0.01, ask=0.99`，说明：
  1. REST API 确实返回了数据（不是空数组）
  2. 但数据可能是错误的（可能是API的默认值或错误数据）

## 影响

### 市场质量门控
- YES价差 98分 >> `marketQualityMaxSpreadCents: 6` → 扣20分
- NO价差 98分 >> `marketQualityMaxSpreadCents: 6` → 扣20分
- 共扣40分，质量分数可能 < `marketQualityMinScore: 30`
- **结果：跳过交易** ❌

## 建议

### 1. 增加调试日志
在 `GetTopOfBook` 函数中增加更详细的日志：
```go
log.Debugf("REST订单簿原始数据: YES bids=%d asks=%d, NO bids=%d asks=%d", 
    len(yesBook.Bids), len(yesBook.Asks), len(noBook.Bids), len(noBook.Asks))
if len(yesBook.Bids) > 0 {
    log.Debugf("YES best bid: %s", yesBook.Bids[0].Price)
}
if len(yesBook.Asks) > 0 {
    log.Debugf("YES best ask: %s", yesBook.Asks[0].Price)
}
```

### 2. 增加价差合理性检查
在策略中增加价差合理性检查：
```go
yesSpread := yesAskDec - yesBidDec
noSpread := noAskDec - noBidDec
if yesSpread > 0.10 || noSpread > 0.10 {  // 价差超过10分
    log.Warnf("⚠️ 订单簿价差异常: YES spread=%.4f, NO spread=%.4f", yesSpread, noSpread)
    return nil  // 跳过交易
}
```

### 3. 优先使用 WebSocket 数据
代码中已经有优先使用 WebSocket 的逻辑：
```go
// 快路径：优先读取 WS 推送的 AtomicBestBook
if book != nil && market != nil && book.IsFresh(3*time.Second) {
    // 使用 WebSocket 数据
}
```
确保 WebSocket 数据正常更新，减少对 REST API 的依赖。

### 4. 检查 REST API 响应
检查 Polymarket REST API 返回的原始数据，确认：
- 订单簿是否真的为空
- 返回的价格数据是否正确
- 是否有错误或异常响应

## 配置建议

当前配置 `marketQualityMaxSpreadCents: 8` 是合理的：
- 正常情况下价差1-6分，8分足够
- 如果价差超过8分，说明市场流动性有问题，应该跳过交易

**不建议过度放宽** `marketQualityMaxSpreadCents`，因为：
- 价差过大 = 滑点风险高
- 可能导致实际成交价与预期价格偏差很大
- 影响策略的盈亏比

