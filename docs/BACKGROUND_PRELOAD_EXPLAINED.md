# "后台预加载每1分钟检查" 详解

## 简单理解

**"后台预加载每1分钟检查"** 意思是：

每隔 1 分钟，程序会在**后台**（不影响主交易）自动检查一下：
- 未来需要哪些市场数据？
- 哪些数据还没有准备好？
- 如果缺少，就提前去获取

## 详细解释

### 1. "后台"是什么意思？

**后台** = 在独立的线程（goroutine）中运行，**不阻塞主交易流程**

```
主交易线程（处理价格、下单）
   ↓
后台预加载线程（独立运行，不影响主线程）
   ↓
每1分钟自动检查一次
```

### 2. "每1分钟检查"做什么？

每1分钟，程序会：

1. **检查缓存**：看看未来100个周期的市场数据，哪些已经在缓存中了
2. **找出缺失的**：哪些市场数据还没有准备好
3. **优先处理**：如果发现即将到来的周期（下一个、下下个）缺失，立即去获取
4. **长期补充**：其他缺失的数据也在后台慢慢获取

### 3. 具体流程

```
时间轴示例：

00:00 - 程序启动
   ↓
00:01 - 第1次检查
   ├─ 检查未来100个周期
   ├─ 发现缺失：第1、2、3、...、100个周期
   └─ 开始预加载（优先第1、2、3个周期）
   
00:02 - 第2次检查
   ├─ 检查未来100个周期
   ├─ 发现缺失：第4、5、...、100个周期（前3个已加载）
   └─ 继续预加载
   
00:03 - 第3次检查
   ├─ 检查未来100个周期
   ├─ 发现缺失：第5、6、...、100个周期
   └─ 继续预加载
   
...（每1分钟检查一次）

14:58 - 周期结束前2分钟
   ├─ 检查下一个周期（第2个周期）
   ├─ 如果缺失，立即预加载
   └─ 确保切换时数据已准备好
   
15:00 - 周期切换
   ├─ 从缓存读取下一个周期数据
   └─ < 1 微秒，零延迟！✅
```

## 为什么要每1分钟检查？

### 场景对比

#### 如果每5分钟检查一次（之前的设计）

```
00:00 - 检查，发现缺失，开始预加载
00:05 - 检查，继续预加载
00:10 - 检查，继续预加载
...
14:55 - 检查，发现下一个周期缺失
   ↓
14:55-15:00 - 只有5分钟时间预加载
   ↓
如果API慢或网络问题，可能来不及
   ↓
15:00 - 切换时，数据可能还没准备好 ⚠️
```

#### 每1分钟检查一次（现在的设计）

```
00:00 - 检查，发现缺失，开始预加载
00:01 - 检查，继续预加载
00:02 - 检查，继续预加载
...
14:58 - 检查，发现下一个周期缺失
   ↓
14:58-15:00 - 有2分钟时间预加载
   ↓
更及时，更安全 ✅
   ↓
15:00 - 切换时，数据已准备好 ✅
```

## 代码实现

### 启动后台预加载

```go
// 在 MarketDataService.Start() 中
func (s *MarketDataService) Start() {
    // 启动后台预加载 goroutine
    go s.startBackgroundPreload()
}

// 后台预加载循环
func (s *MarketDataService) startBackgroundPreload() {
    // 创建一个定时器，每1分钟触发一次
    ticker := time.NewTicker(1 * time.Minute)
    
    // 立即执行一次（不等待1分钟）
    s.preloadFutureMarkets()
    
    // 循环：每1分钟执行一次
    for {
        select {
        case <-ticker.C:  // 每1分钟触发
            s.preloadFutureMarkets()  // 执行检查
        }
    }
}
```

### 检查逻辑

```go
func (s *MarketDataService) preloadFutureMarkets() {
    // 1. 生成未来100个周期的列表
    slugs := GenerateNext15MinSlugs(100)
    
    // 2. 检查缓存，找出缺失的
    missingSlugs := []
    for slug in slugs {
        if 缓存中没有这个slug {
            missingSlugs.append(slug)
        }
    }
    
    // 3. 如果都齐全，就返回（不需要做什么）
    if len(missingSlugs) == 0 {
        return  // 数据都准备好了，不需要预加载
    }
    
    // 4. 如果有缺失，就异步去获取（不阻塞）
    go func() {
        for slug in missingSlugs {
            // 从API获取数据
            market = fetchFromAPI(slug)
            // 存入缓存
            cache[slug] = market
        }
    }()
}
```

## 实际例子

### 例子1：正常情况（数据已准备好）

```
14:58 - 第1分钟检查
   ├─ 检查未来100个周期
   ├─ 发现：所有数据都已存在
   └─ 记录日志："后台预加载检查: 未来市场数据已全部存在"
   
14:59 - 第2分钟检查
   ├─ 检查未来100个周期
   ├─ 发现：所有数据都已存在
   └─ 记录日志："后台预加载检查: 未来市场数据已全部存在"
   
15:00 - 周期切换
   └─ 从缓存读取，< 1 微秒 ✅
```

### 例子2：发现缺失数据

```
14:58 - 第1分钟检查
   ├─ 检查未来100个周期
   ├─ 发现缺失：第2、3、50、51个周期
   └─ 开始预加载（优先第2、3个周期）
   
14:59 - 第2分钟检查
   ├─ 检查未来100个周期
   ├─ 发现缺失：第50、51个周期（第2、3个已加载）
   └─ 继续预加载第50、51个周期
   
15:00 - 周期切换
   └─ 从缓存读取第2个周期，< 1 微秒 ✅
```

## 关键点总结

### 1. "后台" = 不阻塞主线程
- 在独立的 goroutine 中运行
- 不影响主交易流程
- 所有操作都是异步的

### 2. "每1分钟检查" = 定期检查
- 使用 `time.Ticker` 定时器
- 每1分钟自动触发一次
- 检查缓存，找出缺失的数据

### 3. "预加载" = 提前获取
- 如果发现缺失，就去API获取
- 存入内存缓存
- 下次需要时，直接从缓存读取（极快）

### 4. 为什么是1分钟？
- **更及时**：能更早发现缺失的数据
- **更安全**：有更多时间预加载
- **不影响性能**：检查本身很快（只是读缓存），预加载是异步的

## 性能影响

### 对主线程的影响
- **检查操作**：只是读缓存（O(1)），< 1 微秒
- **预加载操作**：在独立的 goroutine 中，完全异步
- **结论**：**零影响** ✅

### 资源占用
- **内存**：每个市场约 200 字节，100 个市场约 20KB
- **CPU**：几乎为零（只是读 map）
- **网络**：仅在缺失时调用 API，且是异步的

## 总结

**"后台预加载每1分钟检查"** 就是：

每隔1分钟，程序在后台自动检查一下未来需要的市场数据是否都准备好了。如果发现缺失，就提前去获取，确保在需要时（周期切换时）数据已经在缓存中，实现**零延迟切换**。

这是一个**智能、自动、高效**的机制，完全不影响主交易流程的性能。

