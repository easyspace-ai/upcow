# 订单簿数据源优先级说明

## 📊 数据源优先级顺序

代码已经实现了**优先使用 WebSocket，必要时回退 REST API**的逻辑。

### 1. GetTopOfBook（策略使用的主要接口）

```go
// internal/services/trading_orders.go:316-398

func GetTopOfBook(ctx context.Context, market *domain.Market) {
    // ===== 第一优先级：WebSocket 数据 =====
    if WebSocket数据可用 && 数据新鲜（<10秒） && 数据完整（YES/NO都有） {
        return WebSocket数据  // ✅ 立即返回，source="ws.bestbook"
    }
    
    // ===== 第二优先级：REST API 回退 =====
    // 只有在 WebSocket 不可用时才调用 REST API
    yesBook = REST_API.GetOrderBook(market.YesAssetID)  // 第一次调用
    noBook = REST_API.GetOrderBook(market.NoAssetID)    // 第二次调用
    
    return 解析后的价格  // source="rest.orderbook"
}
```

**优先级：**
1. ✅ **WebSocket (ws.bestbook)** - 优先使用
   - 条件：数据新鲜（<10秒）、数据完整（YES/NO都有bid/ask）
   - 优势：实时、低延迟、不阻塞
   
2. ⚠️ **REST API (rest.orderbook)** - 回退方案
   - 条件：WebSocket 不可用、数据过期、数据不完整
   - 劣势：需要调用2次API、可能超时、延迟较高

### 2. GetBestPrice（单个资产价格）

```go
// internal/services/trading_orders.go:228-311

func GetBestPrice(ctx context.Context, assetID string) {
    // ===== 第一优先级：WebSocket 数据 =====
    if WebSocket数据可用 && 数据新鲜（<3秒） && 价差合理（<=10分） {
        return WebSocket数据  // ✅ 立即返回
    }
    
    // ===== 第二优先级：REST API 回退 =====
    book = REST_API.GetOrderBook(assetID)
    return 解析后的价格
}
```

**优先级：**
1. ✅ **WebSocket** - 优先使用（新鲜度要求3秒）
2. ⚠️ **REST API** - 回退方案

### 3. GetMarketQuality（市场质量评估）

```go
// internal/services/market_quality.go:109-290

func GetMarketQuality(ctx context.Context, market *domain.Market, opt *MarketQualityOptions) {
    // ===== 第一优先级：WebSocket 数据 =====
    if opts.PreferWS && WebSocket数据可用 {
        // 使用 WebSocket 数据
        chosenSource = "ws.bestbook"
    }
    
    // ===== 第二优先级：REST API 回退 =====
    if opts.FallbackToREST && (WebSocket不可用 || 需要完整数据) {
        // 使用 REST API 数据
        chosenSource = "rest.orderbook"
    }
}
```

**优先级：**
1. ✅ **WebSocket (ws.bestbook)** - 优先使用
2. ⚠️ **REST API (rest.orderbook)** - 回退方案

## 🔍 WebSocket 数据检查条件

### GetTopOfBook 的 WebSocket 检查

```go
// 检查条件：
1. book != nil                    // WebSocket 连接存在
2. cur != nil                     // 当前市场信息存在
3. cur.Slug == market.Slug        // 市场匹配
4. book.IsFresh(10*time.Second)   // 数据新鲜（<10秒）
5. snap.YesBidPips > 0            // YES bid 存在
6. snap.YesAskPips > 0            // YES ask 存在
7. snap.NoBidPips > 0             // NO bid 存在
8. snap.NoAskPips > 0             // NO ask 存在
```

**如果以上任一条件不满足，会回退到 REST API**

### GetBestPrice 的 WebSocket 检查

```go
// 检查条件：
1. book != nil                    // WebSocket 连接存在
2. market != nil                   // 市场信息存在
3. book.IsFresh(3*time.Second)     // 数据新鲜（<3秒）
4. assetID 匹配                    // YES 或 NO
5. bid > 0 && ask > 0              // 双边价格存在
6. spread <= 10分                  // 价差合理（防止脏数据）
```

**如果价差 > 10分，会回退到 REST API 再确认**

## 📝 日志中的 source 字段

日志中可以看到数据来源：

```
📊 [velocityfollow] 订单簿价格: YES bid=0.0100 ask=0.9900, NO bid=0.0100 ask=0.9900 (source=rest.orderbook)
```

**source 字段说明：**
- `ws.bestbook` - 来自 WebSocket，数据正常 ✅
- `rest.orderbook` - 来自 REST API，说明 WebSocket 不可用 ⚠️

## 🚨 为什么日志中显示 rest.orderbook？

从日志看，大部分情况下都是 `source=rest.orderbook`，说明：

1. **WebSocket 数据不可用**
   - WebSocket 连接可能断开
   - 数据可能不新鲜（>10秒）
   - 数据可能不完整（缺少 YES 或 NO 的 bid/ask）

2. **回退到 REST API**
   - 代码逻辑正确执行了回退
   - 但 REST API 返回的数据可能有问题（bid=0.01, ask=0.99）

## 💡 优化建议

### 1. 检查 WebSocket 连接状态

增加日志输出 WebSocket 数据状态：
```go
if book != nil {
    snap := book.Load()
    log.Debugf("WebSocket数据状态: YES bid=%d ask=%d, NO bid=%d ask=%d, 更新时间=%v",
        snap.YesBidPips, snap.YesAskPips, snap.NoBidPips, snap.NoAskPips, snap.UpdatedAt)
}
```

### 2. 增加 WebSocket 数据有效性检查

在回退到 REST 之前，记录为什么 WebSocket 不可用：
```go
if book == nil {
    log.Debugf("WebSocket不可用: book为nil")
} else if cur == nil {
    log.Debugf("WebSocket不可用: 当前市场信息为nil")
} else if cur.Slug != market.Slug {
    log.Debugf("WebSocket不可用: 市场不匹配 cur=%s expected=%s", cur.Slug, market.Slug)
} else if !book.IsFresh(10*time.Second) {
    log.Debugf("WebSocket不可用: 数据过期 age=%v", time.Since(snap.UpdatedAt))
} else if snap.YesBidPips == 0 || snap.YesAskPips == 0 || snap.NoBidPips == 0 || snap.NoAskPips == 0 {
    log.Debugf("WebSocket不可用: 数据不完整 YES bid=%d ask=%d NO bid=%d ask=%d",
        snap.YesBidPips, snap.YesAskPips, snap.NoBidPips, snap.NoAskPips)
}
```

### 3. REST API 数据验证

在解析 REST API 数据时，增加价差合理性检查：
```go
yesSpread := yesAskDec - yesBidDec
noSpread := noAskDec - noBidDec
if yesSpread > 0.10 || noSpread > 0.10 {  // 价差超过10分
    log.Warnf("⚠️ REST API返回异常价差: YES spread=%.4f, NO spread=%.4f", yesSpread, noSpread)
    return fmt.Errorf("订单簿价差异常: YES spread=%.4f NO spread=%.4f", yesSpread, noSpread)
}
```

## ✅ 总结

**代码已经实现了优先使用 WebSocket 的逻辑**，但需要：

1. ✅ **确保 WebSocket 连接正常**
2. ✅ **确保 WebSocket 数据及时更新**
3. ✅ **增加调试日志，了解为什么回退到 REST API**
4. ✅ **增加 REST API 数据验证，防止异常数据**

当前的问题是：**WebSocket 数据不可用，回退到 REST API，但 REST API 返回了异常数据（价差98分）**。

