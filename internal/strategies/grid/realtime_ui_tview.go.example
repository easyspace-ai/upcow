// è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨ tview å®žçŽ°çš„å®žæ—¶UIç¤ºä¾‹
// ä½¿ç”¨æ–¹æ³•ï¼š
// 1. å®‰è£…ä¾èµ–: go get github.com/rivo/tview
// 2. å°†æ­¤æ–‡ä»¶é‡å‘½åä¸º realtime_ui_tview.go
// 3. æ›¿æ¢ strategy.go ä¸­çš„ updateRealtimeUI å®žçŽ°

package grid

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/rivo/tview"
	"github.com/sirupsen/logrus"

	"github.com/betbot/gobet/internal/domain"
)

var log = logrus.WithField("strategy", "grid")

// RealtimeUITView ä½¿ç”¨tviewå®žçŽ°çš„å®žæ—¶UI
type RealtimeUITView struct {
	app          *tview.Application
	grid         *tview.Grid
	priceView    *tview.TextView
	positionView *tview.TextView
	orderView    *tview.Table
	holdingView  *tview.TextView
	roundView    *tview.TextView
	
	// æ•°æ®ç¼“å­˜
	mu                sync.RWMutex
	currentMarketSlug string
	currentPriceUp    int
	currentPriceDown  int
	activePosition    *domain.Position
	activeOrders      []*domain.Order
	upTotalCost       float64
	upHoldings        float64
	downTotalCost     float64
	downHoldings      float64
	roundsThisPeriod  int
	maxRounds         int
	isPlacingOrder    bool
}

// NewRealtimeUITView åˆ›å»ºæ–°çš„tview UIå®žä¾‹
func NewRealtimeUITView() *RealtimeUITView {
	app := tview.NewApplication()
	
	// åˆ›å»ºä»·æ ¼æ˜¾ç¤ºç»„ä»¶
	priceView := tview.NewTextView().
		SetDynamicColors(true).
		SetBorder(true).
		SetTitle("ðŸ’° å½“å‰ä»·æ ¼").
		SetTitleAlign(tview.AlignLeft)
	
	// åˆ›å»ºæŒä»“æ˜¾ç¤ºç»„ä»¶
	positionView := tview.NewTextView().
		SetDynamicColors(true).
		SetBorder(true).
		SetTitle("ðŸ’¼ æŒä»“æƒ…å†µ").
		SetTitleAlign(tview.AlignLeft)
	
	// åˆ›å»ºè®¢å•è¡¨æ ¼
	orderView := tview.NewTable().
		SetBorders(true).
		SetTitle("ðŸ“‹ è®¢å•çŠ¶æ€").
		SetTitleAlign(tview.AlignLeft).
		SetSelectable(false, false)
	
	// åˆ›å»ºåŒå‘æŒä»“æ˜¾ç¤ºç»„ä»¶
	holdingView := tview.NewTextView().
		SetDynamicColors(true).
		SetBorder(true).
		SetTitle("ðŸ“Š åŒå‘æŒä»“").
		SetTitleAlign(tview.AlignLeft)
	
	// åˆ›å»ºè½®æ•°æ˜¾ç¤ºç»„ä»¶
	roundView := tview.NewTextView().
		SetDynamicColors(true).
		SetBorder(true).
		SetTitle("ðŸ“Š è½®æ•°ä¿¡æ¯").
		SetTitleAlign(tview.AlignLeft)
	
	// åˆ›å»ºå¸ƒå±€
	grid := tview.NewGrid().
		SetRows(3, 0, 0, 3).
		SetColumns(0, 0).
		SetBorders(false).
		// æ ‡é¢˜è¡Œï¼ˆè·¨2åˆ—ï¼‰
		AddItem(createTitleView(), 0, 0, 1, 2, 0, 0, false).
		// ä»·æ ¼å’ŒæŒä»“ï¼ˆç¬¬ä¸€è¡Œï¼‰
		AddItem(priceView, 1, 0, 1, 1, 0, 0, false).
		AddItem(positionView, 1, 1, 1, 1, 0, 0, false).
		// è®¢å•å’ŒåŒå‘æŒä»“ï¼ˆç¬¬äºŒè¡Œï¼‰
		AddItem(orderView, 2, 0, 1, 1, 0, 0, false).
		AddItem(holdingView, 2, 1, 1, 1, 0, 0, false).
		// è½®æ•°ä¿¡æ¯ï¼ˆåº•éƒ¨ï¼‰
		AddItem(roundView, 3, 0, 1, 2, 0, 0, false)
	
	app.SetRoot(grid, true)
	
	return &RealtimeUITView{
		app:          app,
		grid:         grid,
		priceView:    priceView,
		positionView: positionView,
		orderView:    orderView,
		holdingView:  holdingView,
		roundView:    roundView,
	}
}

// createTitleView åˆ›å»ºæ ‡é¢˜è§†å›¾
func createTitleView() *tview.TextView {
	title := tview.NewTextView().
		SetDynamicColors(true).
		SetTextAlign(tview.AlignCenter).
		SetText("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n" +
			"â•‘              ç½‘æ ¼äº¤æ˜“ç­–ç•¥ - å®žæ—¶ç›‘æŽ§é¢æ¿                      â•‘\n" +
			"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	return title
}

// Update æ›´æ–°UIæ•°æ®ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
func (ui *RealtimeUITView) Update(data *UIUpdateData) {
	ui.mu.Lock()
	defer ui.mu.Unlock()
	
	ui.currentMarketSlug = data.CurrentMarketSlug
	ui.currentPriceUp = data.CurrentPriceUp
	ui.currentPriceDown = data.CurrentPriceDown
	ui.activePosition = data.ActivePosition
	ui.activeOrders = data.ActiveOrders
	ui.upTotalCost = data.UpTotalCost
	ui.upHoldings = data.UpHoldings
	ui.downTotalCost = data.DownTotalCost
	ui.downHoldings = data.DownHoldings
	ui.roundsThisPeriod = data.RoundsThisPeriod
	ui.maxRounds = data.MaxRounds
	ui.isPlacingOrder = data.IsPlacingOrder
	
	// ä½¿ç”¨ QueueUpdateDraw ç¡®ä¿åœ¨ä¸»çº¿ç¨‹æ›´æ–°UI
	ui.app.QueueUpdateDraw(func() {
		ui.render()
	})
}

// render æ¸²æŸ“UIï¼ˆåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ï¼‰
func (ui *RealtimeUITView) render() {
	ui.mu.RLock()
	defer ui.mu.RUnlock()
	
	// æ›´æ–°ä»·æ ¼æ˜¾ç¤º
	ui.updatePriceView()
	
	// æ›´æ–°æŒä»“æ˜¾ç¤º
	ui.updatePositionView()
	
	// æ›´æ–°è®¢å•è¡¨æ ¼
	ui.updateOrderView()
	
	// æ›´æ–°åŒå‘æŒä»“æ˜¾ç¤º
	ui.updateHoldingView()
	
	// æ›´æ–°è½®æ•°æ˜¾ç¤º
	ui.updateRoundView()
}

// updatePriceView æ›´æ–°ä»·æ ¼æ˜¾ç¤º
func (ui *RealtimeUITView) updatePriceView() {
	var text string
	
	if ui.currentPriceUp > 0 {
		text += fmt.Sprintf("[green]UP:   [white]%dc (%.4f)\n", ui.currentPriceUp, float64(ui.currentPriceUp)/100.0)
	} else {
		text += "[yellow]UP:   ç­‰å¾…ä»·æ ¼æ›´æ–°...\n"
	}
	
	if ui.currentPriceDown > 0 {
		text += fmt.Sprintf("[green]DOWN: [white]%dc (%.4f)", ui.currentPriceDown, float64(ui.currentPriceDown)/100.0)
	} else {
		text += "[yellow]DOWN: ç­‰å¾…ä»·æ ¼æ›´æ–°..."
	}
	
	ui.priceView.SetText(text)
}

// updatePositionView æ›´æ–°æŒä»“æ˜¾ç¤º
func (ui *RealtimeUITView) updatePositionView() {
	var text string
	
	if ui.activePosition != nil {
		hedgeStatus := "[yellow]âš ï¸ æœªå¯¹å†²"
		if ui.activePosition.IsHedged() {
			hedgeStatus = "[green]âœ… å·²å¯¹å†²"
		}
		
		// è®¡ç®—ç›ˆäº
		profitInfo := ""
		if ui.activePosition.TokenType == domain.TokenTypeUp && ui.currentPriceUp > 0 {
			currentPrice := domain.Price{Cents: ui.currentPriceUp}
			profit := ui.activePosition.CalculateProfit(currentPrice)
			if profit > 0 {
				profitInfo = fmt.Sprintf(" | [green]åˆ©æ¶¦: +%dc", profit)
			} else if profit < 0 {
				profitInfo = fmt.Sprintf(" | [red]äºæŸ: %dc", profit)
			}
		} else if ui.activePosition.TokenType == domain.TokenTypeDown && ui.currentPriceDown > 0 {
			currentPrice := domain.Price{Cents: ui.currentPriceDown}
			profit := ui.activePosition.CalculateProfit(currentPrice)
			if profit > 0 {
				profitInfo = fmt.Sprintf(" | [green]åˆ©æ¶¦: +%dc", profit)
			} else if profit < 0 {
				profitInfo = fmt.Sprintf(" | [red]äºæŸ: %dc", profit)
			}
		}
		
		text = fmt.Sprintf("[white]%så¸ @ %dc, æ•°é‡=%.2f | %s%s",
			ui.activePosition.TokenType, ui.activePosition.EntryPrice.Cents, ui.activePosition.Size, hedgeStatus, profitInfo)
	} else {
		text = "[gray]æ— æŒä»“"
	}
	
	ui.positionView.SetText(text)
}

// updateOrderView æ›´æ–°è®¢å•è¡¨æ ¼
func (ui *RealtimeUITView) updateOrderView() {
	ui.orderView.Clear()
	
	if ui.isPlacingOrder {
		ui.orderView.SetCell(0, 0, tview.NewTableCell("[yellow]â³ æ­£åœ¨ä¸‹å•ä¸­..."))
	} else if len(ui.activeOrders) > 0 {
		// è¡¨å¤´
		ui.orderView.SetCell(0, 0, tview.NewTableCell("[yellow]ç±»åž‹").SetAlign(tview.AlignCenter))
		ui.orderView.SetCell(0, 1, tview.NewTableCell("[yellow]å¸ç§").SetAlign(tview.AlignCenter))
		ui.orderView.SetCell(0, 2, tview.NewTableCell("[yellow]ä»·æ ¼").SetAlign(tview.AlignCenter))
		ui.orderView.SetCell(0, 3, tview.NewTableCell("[yellow]æ•°é‡").SetAlign(tview.AlignCenter))
		ui.orderView.SetCell(0, 4, tview.NewTableCell("[yellow]çŠ¶æ€").SetAlign(tview.AlignCenter))
		
		// è®¢å•æ•°æ®
		for i, order := range ui.activeOrders {
			row := i + 1
			orderType := "[green]å…¥åœº"
			if !order.IsEntryOrder {
				orderType = "[cyan]å¯¹å†²"
			}
			
			ui.orderView.SetCell(row, 0, tview.NewTableCell(orderType))
			ui.orderView.SetCell(row, 1, tview.NewTableCell(order.TokenType))
			ui.orderView.SetCell(row, 2, tview.NewTableCell(fmt.Sprintf("%dc", order.Price.Cents)))
			ui.orderView.SetCell(row, 3, tview.NewTableCell(fmt.Sprintf("%.2f", order.Size)))
			ui.orderView.SetCell(row, 4, tview.NewTableCell(order.Status))
		}
	} else {
		ui.orderView.SetCell(0, 0, tview.NewTableCell("[gray]æ— å¾…æˆäº¤è®¢å•"))
	}
}

// updateHoldingView æ›´æ–°åŒå‘æŒä»“æ˜¾ç¤º
func (ui *RealtimeUITView) updateHoldingView() {
	var upAvgPrice, downAvgPrice float64
	if ui.upHoldings > 0 {
		upAvgPrice = ui.upTotalCost / ui.upHoldings
	}
	if ui.downHoldings > 0 {
		downAvgPrice = ui.downTotalCost / ui.downHoldings
	}
	
	// è®¡ç®—åˆ©æ¶¦
	upWinProfit := ui.upHoldings*1.0 - ui.upTotalCost - ui.downTotalCost
	downWinProfit := ui.downHoldings*1.0 - ui.upTotalCost - ui.downTotalCost
	upWinColor := "[green]"
	if upWinProfit < 0 {
		upWinColor = "[red]"
	}
	downWinColor := "[green]"
	if downWinProfit < 0 {
		downWinColor = "[red]"
	}
	
	text := fmt.Sprintf("[white]UP:   æ€»æˆæœ¬=%.8f USDC, æŒä»“=%.8f, å‡ä»·=%.8f\n",
		ui.upTotalCost, ui.upHoldings, upAvgPrice)
	text += fmt.Sprintf("[white]DOWN: æ€»æˆæœ¬=%.8f USDC, æŒä»“=%.8f, å‡ä»·=%.8f\n",
		ui.downTotalCost, ui.downHoldings, downAvgPrice)
	text += fmt.Sprintf("[yellow]ðŸ’° åˆ©æ¶¦: UPèƒœ=%s%.8f[white] USDC, DOWNèƒœ=%s%.8f[white] USDC",
		upWinColor, upWinProfit, downWinColor, downWinProfit)
	
	ui.holdingView.SetText(text)
}

// updateRoundView æ›´æ–°è½®æ•°æ˜¾ç¤º
func (ui *RealtimeUITView) updateRoundView() {
	text := fmt.Sprintf("[white]ðŸ“Š è½®æ•°: %d/%d", ui.roundsThisPeriod, ui.maxRounds)
	if ui.currentMarketSlug != "" {
		text += fmt.Sprintf(" | [cyan]å‘¨æœŸ: %s", ui.currentMarketSlug)
	}
	text += fmt.Sprintf(" | [gray]æ›´æ–°æ—¶é—´: %s", time.Now().Format("2006-01-02 15:04:05"))
	
	ui.roundView.SetText(text)
}

// Run è¿è¡ŒUIï¼ˆé˜»å¡žè°ƒç”¨ï¼‰
func (ui *RealtimeUITView) Run() error {
	return ui.app.Run()
}

// Stop åœæ­¢UI
func (ui *RealtimeUITView) Stop() {
	ui.app.Stop()
}

// UIUpdateData UIæ›´æ–°æ•°æ®ç»“æž„
type UIUpdateData struct {
	CurrentMarketSlug string
	CurrentPriceUp    int
	CurrentPriceDown  int
	ActivePosition    *domain.Position
	ActiveOrders      []*domain.Order
	UpTotalCost       float64
	UpHoldings        float64
	DownTotalCost     float64
	DownHoldings      float64
	RoundsThisPeriod  int
	MaxRounds         int
	IsPlacingOrder    bool
}

// åœ¨ strategy.go ä¸­çš„ä½¿ç”¨ç¤ºä¾‹ï¼š
/*
func (s *GridStrategy) startRealtimeUI(ctx context.Context) {
	// ... çŽ°æœ‰ä»£ç  ...
	
	// åˆ›å»ºtview UI
	ui := NewRealtimeUITView()
	
	// åœ¨goroutineä¸­è¿è¡ŒUI
	go func() {
		if err := ui.Run(); err != nil {
			log.Errorf("UIè¿è¡Œå¤±è´¥: %v", err)
		}
	}()
	
	// å®šæœŸæ›´æ–°UI
	go func() {
		ticker := time.NewTicker(500 * time.Millisecond)
		defer ticker.Stop()
		
		for {
			select {
			case <-ctx.Done():
				ui.Stop()
				return
			case <-ticker.C:
				// è¯»å–æ•°æ®
				data := s.getUIUpdateData()
				// æ›´æ–°UI
				ui.Update(data)
			}
		}
	}()
}

func (s *GridStrategy) getUIUpdateData() *UIUpdateData {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	data := &UIUpdateData{
		CurrentMarketSlug: s.currentMarketSlug,
		CurrentPriceUp:    s.currentPriceUp,
		CurrentPriceDown:  s.currentPriceDown,
		UpTotalCost:       s.upTotalCost,
		UpHoldings:        s.upHoldings,
		DownTotalCost:     s.downTotalCost,
		DownHoldings:      s.downHoldings,
		RoundsThisPeriod:  s.roundsThisPeriod,
		MaxRounds:         s.config.MaxRoundsPerPeriod,
		IsPlacingOrder:   s.isPlacingOrder,
	}
	
	// å¤åˆ¶ä»“ä½
	if s.activePosition != nil {
		posCopy := *s.activePosition
		data.ActivePosition = &posCopy
	}
	
	// å¤åˆ¶è®¢å•
	data.ActiveOrders = make([]*domain.Order, 0, len(s.activeOrders))
	for _, order := range s.activeOrders {
		if order.Status == domain.OrderStatusPending || order.Status == domain.OrderStatusOpen {
			orderCopy := *order
			data.ActiveOrders = append(data.ActiveOrders, &orderCopy)
		}
	}
	
	return data
}
*/

