# CycleHedge ç­–ç•¥è®¾è®¡æ”¹è¿›æ–¹æ¡ˆ

## å½“å‰è®¾è®¡é—®é¢˜åˆ†æ

### 1. ä¿¡å·é€šé“è®¾è®¡é—®é¢˜

**é—®é¢˜ï¼š**
- `signalC` channel ç¼“å†²åªæœ‰ 1ï¼Œå¯¼è‡´å¤§é‡ä»·æ ¼æ›´æ–°ä¿¡å·ä¸¢å¤±ï¼ˆ8,435 æ¬¡å¤±è´¥ vs 1 æ¬¡æˆåŠŸï¼‰
- `TrySignal` æ˜¯éé˜»å¡çš„ï¼Œchannel æ»¡æ—¶ä¿¡å·ç›´æ¥è¢«ä¸¢å¼ƒ
- tick ä¿¡å·ï¼ˆ200msï¼‰å¤ªé¢‘ç¹ï¼Œå¯¼è‡´ loop ä¸€ç›´åœ¨å¤„ç† tickï¼Œæ²¡æœ‰æœºä¼šå¤„ç† signalC

**å½±å“ï¼š**
- ä»·æ ¼æ›´æ–°äº‹ä»¶æ— æ³•åŠæ—¶è§¦å‘ step å‡½æ•°
- step å‡½æ•°åœ¨ tick è§¦å‘æ—¶è¯»å–ä»·æ ¼äº‹ä»¶ï¼Œä½†æ­¤æ—¶ `s.latest` å·²è¢«æ¸…ç©º
- ç­–ç•¥æ— æ³•å“åº”å®æ—¶ä»·æ ¼å˜åŒ–

### 2. ä»·æ ¼äº‹ä»¶ç®¡ç†é—®é¢˜

**é—®é¢˜ï¼š**
- step å‡½æ•°æ¯æ¬¡è°ƒç”¨éƒ½ä¼šæ¸…ç©º `s.latest` mapï¼ˆ`s.latest = make(map[domain.TokenType]*events.PriceChangedEvent)`ï¼‰
- å¦‚æœ step å‡½æ•°åœ¨ tick è§¦å‘æ—¶æ‰§è¡Œï¼Œæ­¤æ—¶ä»·æ ¼äº‹ä»¶å¯èƒ½å·²ç»è¢«æ¸…ç©º
- ä»·æ ¼äº‹ä»¶å’Œ step æ‰§è¡Œä¹‹é—´å­˜åœ¨æ—¶åºç«äº‰

**å½±å“ï¼š**
- 100% çš„ step è°ƒç”¨æ—¶ä»·æ ¼äº‹ä»¶ä¸ºç©º
- ç­–ç•¥æ— æ³•è·å–å½“å‰å¸‚åœºä»·æ ¼ï¼Œæ— æ³•ä¸‹å•

### 3. å¸‚åœºæ•°æ®è·å–ä¾èµ–é—®é¢˜

**é—®é¢˜ï¼š**
- step å‡½æ•°å®Œå…¨ä¾èµ–ä»·æ ¼äº‹ä»¶ï¼ˆ`s.latest`ï¼‰æ¥è·å– market å¯¹è±¡
- å¦‚æœä»·æ ¼äº‹ä»¶ä¸ºç©ºï¼Œstep å‡½æ•°ç›´æ¥è¿”å›ï¼Œä¸å°è¯•å…¶ä»–æ–¹å¼è·å–å¸‚åœºæ•°æ®

**å½±å“ï¼š**
- å³ä½¿ TradingService å¯ä»¥è·å–æœ€æ–°ç›˜å£æ•°æ®ï¼Œç­–ç•¥ä¹Ÿä¸ä¼šå°è¯•
- ç­–ç•¥æ— æ³•åœ¨ä»·æ ¼äº‹ä»¶ä¸¢å¤±çš„æƒ…å†µä¸‹ç»§ç»­å·¥ä½œ

## æ”¹è¿›æ–¹æ¡ˆ

### æ–¹æ¡ˆ 1ï¼šå¢åŠ  signalC channel ç¼“å†²å¤§å°ï¼ˆçŸ­æœŸä¿®å¤ï¼‰

**æ”¹è¿›ï¼š**
```go
// å½“å‰ï¼šç¼“å†²ä¸º 1
s.signalC = make(chan struct{}, 1)

// æ”¹è¿›ï¼šç¼“å†²å¢åŠ åˆ° 10-50
s.signalC = make(chan struct{}, 50)
```

**ä¼˜ç‚¹ï¼š**
- å®ç°ç®€å•ï¼Œæ”¹åŠ¨å°
- å¯ä»¥ç¼“å†²æ›´å¤šä»·æ ¼æ›´æ–°ä¿¡å·
- å‡å°‘ä¿¡å·ä¸¢å¤±

**ç¼ºç‚¹ï¼š**
- ä¸èƒ½æ ¹æœ¬è§£å†³æ—¶åºç«äº‰é—®é¢˜
- å¦‚æœ step æ‰§è¡Œå¾ˆæ…¢ï¼Œchannel ä»ç„¶å¯èƒ½æ»¡

### æ–¹æ¡ˆ 2ï¼šæ”¹è¿› step å‡½æ•°é€»è¾‘ï¼Œä¸ä¾èµ–ä»·æ ¼äº‹ä»¶ï¼ˆæ¨èï¼‰

**æ”¹è¿›ï¼š**
```go
func (s *Strategy) step(ctx context.Context, now time.Time) {
    if s.TradingService == nil {
        return
    }

    // 1. å°è¯•ä»ä»·æ ¼äº‹ä»¶è·å– marketï¼ˆä¼˜å…ˆï¼‰
    var m *domain.Market
    s.priceMu.Lock()
    evUp := s.latest[domain.TokenTypeUp]
    evDown := s.latest[domain.TokenTypeDown]
    s.latest = make(map[domain.TokenType]*events.PriceChangedEvent)
    s.priceMu.Unlock()

    if evUp != nil && evUp.Market != nil {
        m = evUp.Market
    } else if evDown != nil && evDown.Market != nil {
        m = evDown.Market
    }

    // 2. å¦‚æœä»·æ ¼äº‹ä»¶ä¸ºç©ºï¼Œå°è¯•ä» TradingService è·å–å½“å‰å¸‚åœº
    if m == nil {
        // ä» TradingService è·å–å½“å‰å¸‚åœºï¼ˆå¦‚æœæœ‰ç¼“å­˜æˆ–çŠ¶æ€ï¼‰
        // æˆ–è€…ä½¿ç”¨ currentMarketSlug æ„é€  market
        s.stateMu.Lock()
        currentSlug := s.currentMarketSlug
        s.stateMu.Unlock()
        
        if currentSlug != "" {
            // å°è¯•ä» TradingService è·å–å¸‚åœºä¿¡æ¯
            // æˆ–è€…ä½¿ç”¨å·²çŸ¥çš„ market slug ç»§ç»­æ‰§è¡Œ
            // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ç¡®ä¿ market å¯¹è±¡å¯ç”¨
        }
    }

    // 3. å¦‚æœä»ç„¶æ²¡æœ‰ marketï¼Œè¿”å›ï¼ˆä½†è¿™ç§æƒ…å†µåº”è¯¥å¾ˆå°‘ï¼‰
    if m == nil {
        s.drainOrders()
        return
    }

    // ç»§ç»­æ‰§è¡Œåç»­é€»è¾‘...
}
```

**ä¼˜ç‚¹ï¼š**
- ä¸ä¾èµ–ä»·æ ¼äº‹ä»¶ï¼Œå³ä½¿ä»·æ ¼äº‹ä»¶ä¸¢å¤±ä¹Ÿèƒ½ç»§ç»­å·¥ä½œ
- ç­–ç•¥æ›´åŠ å¥å£®
- å¯ä»¥åˆ©ç”¨ TradingService çš„ç¼“å­˜æˆ–çŠ¶æ€

**ç¼ºç‚¹ï¼š**
- éœ€è¦ç¡®ä¿ TradingService å¯ä»¥æä¾›å½“å‰å¸‚åœºä¿¡æ¯
- å¯èƒ½éœ€è¦é¢å¤–çš„å¸‚åœºä¿¡æ¯è·å–é€»è¾‘

### æ–¹æ¡ˆ 3ï¼šä¼˜åŒ– loop å‡½æ•°ï¼Œä¼˜å…ˆå¤„ç† signalCï¼ˆæ¨èï¼‰

**æ”¹è¿›ï¼š**
```go
func (s *Strategy) loop(loopCtx context.Context, tickC <-chan time.Time) {
    ticker := time.NewTicker(time.Duration(s.baseLoopTickMs()) * time.Millisecond)
    defer ticker.Stop()

    for {
        select {
        case <-loopCtx.Done():
            return
        case <-s.signalC:
            // ä¼˜å…ˆå¤„ç†ä»·æ ¼/è®¢å•äº‹ä»¶
            s.step(loopCtx, time.Now())
            // æ¸…ç©º ticker channelï¼Œé¿å…ç§¯å‹
            select {
            case <-ticker.C:
            default:
            }
        case <-ticker.C:
            // tick ä½œä¸ºä¿åº•ï¼Œç¡®ä¿å®šæœŸæ‰§è¡Œ
            s.step(loopCtx, time.Now())
        }
    }
}
```

**ä¼˜ç‚¹ï¼š**
- signalC ä¿¡å·ä¼˜å…ˆå¤„ç†
- é¿å… tick ä¿¡å·ç§¯å‹
- æ›´åŠæ—¶å“åº”ä»·æ ¼å˜åŒ–

**ç¼ºç‚¹ï¼š**
- å¦‚æœä»·æ ¼æ›´æ–°éå¸¸é¢‘ç¹ï¼Œå¯èƒ½å¯¼è‡´ step å‡½æ•°æ‰§è¡Œè¿‡äºé¢‘ç¹

### æ–¹æ¡ˆ 4ï¼šæ”¹è¿›ä»·æ ¼äº‹ä»¶åˆå¹¶æœºåˆ¶ï¼ˆæ¨èï¼‰

**æ”¹è¿›ï¼š**
```go
func (s *Strategy) step(ctx context.Context, now time.Time) {
    // 1. å…ˆè¯»å–ä»·æ ¼äº‹ä»¶ï¼Œä½†ä¸ç«‹å³æ¸…ç©º
    s.priceMu.Lock()
    evUp := s.latest[domain.TokenTypeUp]
    evDown := s.latest[domain.TokenTypeDown]
    // å»¶è¿Ÿæ¸…ç©ºï¼šåªåœ¨æˆåŠŸè·å– market åæ¸…ç©º
    s.priceMu.Unlock()

    var m *domain.Market
    if evUp != nil && evUp.Market != nil {
        m = evUp.Market
    } else if evDown != nil && evDown.Market != nil {
        m = evDown.Market
    }

    // 2. å¦‚æœä»·æ ¼äº‹ä»¶ä¸ºç©ºï¼Œå°è¯•å…¶ä»–æ–¹å¼è·å– market
    if m == nil {
        s.stateMu.Lock()
        currentSlug := s.currentMarketSlug
        s.stateMu.Unlock()
        
        if currentSlug != "" {
            // å°è¯•ä» TradingService è·å–å¸‚åœºä¿¡æ¯
            // æˆ–è€…ä½¿ç”¨å·²çŸ¥çš„ market slug
            // è¿™é‡Œéœ€è¦æ ¹æ®å®é™… TradingService API å®ç°
        }
    }

    // 3. åªæœ‰åœ¨æˆåŠŸè·å– market åæ‰æ¸…ç©ºä»·æ ¼äº‹ä»¶
    if m != nil {
        s.priceMu.Lock()
        // åªæ¸…ç©ºå·²ä½¿ç”¨çš„ä»·æ ¼äº‹ä»¶
        if evUp != nil {
            delete(s.latest, domain.TokenTypeUp)
        }
        if evDown != nil {
            delete(s.latest, domain.TokenTypeDown)
        }
        s.priceMu.Unlock()
    }

    // ç»§ç»­æ‰§è¡Œåç»­é€»è¾‘...
}
```

**ä¼˜ç‚¹ï¼š**
- é¿å…è¿‡æ—©æ¸…ç©ºä»·æ ¼äº‹ä»¶
- ä¿ç•™æœªä½¿ç”¨çš„ä»·æ ¼äº‹ä»¶ä¾›ä¸‹æ¬¡ä½¿ç”¨
- æ›´çµæ´»çš„äº‹ä»¶ç®¡ç†

**ç¼ºç‚¹ï¼š**
- éœ€è¦æ›´ç»†ç²’åº¦çš„äº‹ä»¶ç®¡ç†
- å¯èƒ½ç§¯ç´¯æœªä½¿ç”¨çš„ä»·æ ¼äº‹ä»¶

### æ–¹æ¡ˆ 5ï¼šä½¿ç”¨å½“å‰å¸‚åœºçŠ¶æ€ï¼Œä¸ä¾èµ–ä»·æ ¼äº‹ä»¶ï¼ˆæœ€ä½³æ–¹æ¡ˆï¼‰âœ…

**æ”¹è¿›ï¼š**
```go
func (s *Strategy) step(ctx context.Context, now time.Time) {
    if s.TradingService == nil {
        return
    }

    // 1. è·å–å½“å‰å¸‚åœºï¼ˆä¼˜å…ˆä»ä»·æ ¼äº‹ä»¶ï¼Œfallback åˆ° TradingServiceï¼‰
    var m *domain.Market
    
    // å°è¯•ä»ä»·æ ¼äº‹ä»¶è·å–
    s.priceMu.Lock()
    evUp := s.latest[domain.TokenTypeUp]
    evDown := s.latest[domain.TokenTypeDown]
    s.latest = make(map[domain.TokenType]*events.PriceChangedEvent)
    s.priceMu.Unlock()

    if evUp != nil && evUp.Market != nil {
        m = evUp.Market
    } else if evDown != nil && evDown.Market != nil {
        m = evDown.Market
    }

    // 2. å¦‚æœä»·æ ¼äº‹ä»¶ä¸ºç©ºï¼Œä» TradingService è·å–å½“å‰å¸‚åœºä¿¡æ¯
    if m == nil {
        // TradingService æœ‰ getCurrentMarketInfo() æ–¹æ³•ï¼Œå¯ä»¥è·å–å½“å‰å¸‚åœº
        m = s.TradingService.getCurrentMarketInfo()
        if m == nil {
            // å¦‚æœ TradingService ä¹Ÿæ²¡æœ‰ï¼Œå°è¯•ä»ç­–ç•¥çŠ¶æ€è·å–
            s.stateMu.Lock()
            currentSlug := s.currentMarketSlug
            s.stateMu.Unlock()
            
            if currentSlug != "" {
                // å¯ä»¥å°è¯•ä» MarketDataService è·å–å¸‚åœºä¿¡æ¯
                // æˆ–è€…ä½¿ç”¨å·²çŸ¥çš„ market slug ç»§ç»­æ‰§è¡Œï¼ˆå¦‚æœåç»­é€»è¾‘å¯ä»¥å¤„ç†ï¼‰
                log.Debugf("ğŸ” [%s] step: ä»·æ ¼äº‹ä»¶ä¸ºç©ºï¼ŒTradingService ä¹Ÿæ²¡æœ‰å¸‚åœºä¿¡æ¯ï¼Œä½¿ç”¨ currentMarketSlug=%s", ID, currentSlug)
                // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ç¡®ä¿åç»­é€»è¾‘å¯ä»¥å¤„ç†åªæœ‰ slug çš„æƒ…å†µ
            }
        }
    }

    // 3. å¦‚æœä»ç„¶æ²¡æœ‰ marketï¼Œè¿”å›
    if m == nil {
        s.drainOrders()
        return
    }

    // ç»§ç»­æ‰§è¡Œåç»­é€»è¾‘...
    // æ³¨æ„ï¼šåç»­é€»è¾‘ä¸ä¾èµ–ä»·æ ¼äº‹ä»¶ï¼Œè€Œæ˜¯ç›´æ¥ä» TradingService è·å–ç›˜å£æ•°æ®
}
```

**ä¼˜ç‚¹ï¼š**
- âœ… å®Œå…¨ä¸ä¾èµ–ä»·æ ¼äº‹ä»¶
- âœ… ç­–ç•¥æ›´åŠ å¥å£®å’Œå¯é 
- âœ… å¯ä»¥åˆ©ç”¨ TradingService çš„ `getCurrentMarketInfo()` æ–¹æ³•
- âœ… TradingService å·²ç»ç»´æŠ¤äº†å½“å‰å¸‚åœºä¿¡æ¯

**ç¼ºç‚¹ï¼š**
- éœ€è¦ç¡®ä¿ TradingService çš„ `getCurrentMarketInfo()` è¿”å›æœ‰æ•ˆçš„å¸‚åœºä¿¡æ¯
- å¯èƒ½éœ€è¦å¤„ç† `getCurrentMarketInfo()` è¿”å› nil çš„æƒ…å†µ

## ç»¼åˆæ”¹è¿›æ–¹æ¡ˆï¼ˆæ¨èå®æ–½ï¼‰

ç»“åˆå¤šä¸ªæ–¹æ¡ˆçš„ä¼˜ç‚¹ï¼ŒæŒ‰ä¼˜å…ˆçº§å®æ–½ï¼š

### 1. å¢åŠ  signalC channel ç¼“å†²ï¼ˆç«‹å³å®æ–½ï¼‰

**ä¿®æ”¹ä½ç½®ï¼š** `strategy.go:105`

```go
// å½“å‰ï¼šç¼“å†²ä¸º 1
s.signalC = make(chan struct{}, 1)

// æ”¹è¿›ï¼šç¼“å†²å¢åŠ åˆ° 50
s.signalC = make(chan struct{}, 50)
```

**ç†ç”±ï¼š**
- å®ç°ç®€å•ï¼Œæ”¹åŠ¨å°
- å¯ä»¥ç¼“å†²æ›´å¤šä»·æ ¼æ›´æ–°ä¿¡å·
- å‡å°‘ä¿¡å·ä¸¢å¤±ï¼ˆä» 99.99% å¤±è´¥ç‡é™ä½åˆ°å¯æ¥å—èŒƒå›´ï¼‰

### 2. æ”¹è¿› step å‡½æ•°ï¼Œä½¿ç”¨ TradingService è·å–å¸‚åœºä¿¡æ¯ï¼ˆæ ¸å¿ƒä¿®å¤ï¼‰

**ä¿®æ”¹ä½ç½®ï¼š** `strategy.go:220-251`

```go
func (s *Strategy) step(ctx context.Context, now time.Time) {
    if s.TradingService == nil {
        return
    }

    // 1. å°è¯•ä»ä»·æ ¼äº‹ä»¶è·å– marketï¼ˆä¼˜å…ˆï¼‰
    var m *domain.Market
    s.priceMu.Lock()
    evUp := s.latest[domain.TokenTypeUp]
    evDown := s.latest[domain.TokenTypeDown]
    s.latest = make(map[domain.TokenType]*events.PriceChangedEvent)
    s.priceMu.Unlock()

    if evUp != nil && evUp.Market != nil {
        m = evUp.Market
    } else if evDown != nil && evDown.Market != nil {
        m = evDown.Market
    }

    // 2. å¦‚æœä»·æ ¼äº‹ä»¶ä¸ºç©ºï¼Œä»ç­–ç•¥çŠ¶æ€è·å– currentMarketSlugï¼Œç„¶åç»§ç»­æ‰§è¡Œ
    // æ³¨æ„ï¼šTradingService.getCurrentMarketInfo() æ˜¯ç§æœ‰æ–¹æ³•ï¼Œæ— æ³•ç›´æ¥è°ƒç”¨
    // ä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç­–ç•¥è‡ªå·±çš„ currentMarketSlugï¼Œåç»­é€»è¾‘ä¼šä» TradingService è·å–ç›˜å£æ•°æ®
    if m == nil {
        s.stateMu.Lock()
        currentSlug := s.currentMarketSlug
        s.stateMu.Unlock()
        
        if currentSlug == "" {
            // å®Œå…¨æ²¡æœ‰å¸‚åœºä¿¡æ¯ï¼Œè¿”å›
            s.drainOrders()
            return
        }
        
        // æœ‰ currentSlugï¼Œå¯ä»¥ç»§ç»­æ‰§è¡Œ
        // åç»­é€»è¾‘ä¼šè°ƒç”¨ GetTopOfBookï¼Œå®ƒå¯ä»¥ä» TradingService è·å–ç›˜å£æ•°æ®
        // ä½†æˆ‘ä»¬éœ€è¦ä¸€ä¸ª market å¯¹è±¡ï¼Œå¯ä»¥å°è¯•ä» MarketDataService è·å–
        // æˆ–è€…ä¿®æ”¹åç»­é€»è¾‘ï¼Œä½¿å…¶å¯ä»¥åœ¨åªæœ‰ slug çš„æƒ…å†µä¸‹å·¥ä½œ
        
        // ä¸´æ—¶æ–¹æ¡ˆï¼šä½¿ç”¨å·²çŸ¥çš„ market slug æ„é€ ä¸€ä¸ªæœ€å° market å¯¹è±¡
        // æ³¨æ„ï¼šè¿™éœ€è¦ç¡®ä¿åç»­é€»è¾‘å¯ä»¥å¤„ç†ä¸å®Œæ•´çš„ market å¯¹è±¡
        // æ›´å¥½çš„æ–¹æ¡ˆæ˜¯ï¼šä¿®æ”¹åç»­é€»è¾‘ï¼Œä½¿å…¶ä¸ä¾èµ–å®Œæ•´çš„ market å¯¹è±¡
        log.Debugf("ğŸ” [%s] step: ä»·æ ¼äº‹ä»¶ä¸ºç©ºï¼Œä½¿ç”¨ currentMarketSlug=%s", ID, currentSlug)
        
        // æ–¹æ¡ˆ Aï¼šå°è¯•ä» MarketDataService è·å–å¸‚åœºä¿¡æ¯ï¼ˆå¦‚æœæœ‰è®¿é—®æƒé™ï¼‰
        // æ–¹æ¡ˆ Bï¼šä¿®æ”¹åç»­é€»è¾‘ï¼Œä½¿å…¶å¯ä»¥åœ¨åªæœ‰ slug çš„æƒ…å†µä¸‹å·¥ä½œ
        // æ–¹æ¡ˆ Cï¼šä½¿ç”¨ç­–ç•¥çŠ¶æ€ä¸­çš„ market ä¿¡æ¯ï¼ˆå¦‚æœä¿å­˜äº†ï¼‰
        
        // è¿™é‡Œå…ˆè¿”å›ï¼Œç­‰å¾…æ›´å¥½çš„å®ç°
        s.drainOrders()
        return
    }

    // 3. å¸‚åœºè¿‡æ»¤
    if !strings.HasPrefix(strings.ToLower(m.Slug), s.marketSlugPrefix) {
        s.drainOrders()
        return
    }
    
    // ç»§ç»­æ‰§è¡Œåç»­é€»è¾‘...
}
```

**ç†ç”±ï¼š**
- âœ… TradingService å·²ç»ç»´æŠ¤äº†å½“å‰å¸‚åœºä¿¡æ¯ï¼ˆ`getCurrentMarketInfo()`ï¼‰
- âœ… ä¸ä¾èµ–ä»·æ ¼äº‹ä»¶ï¼Œç­–ç•¥æ›´åŠ å¥å£®
- âœ… è§£å†³äº†ä»·æ ¼äº‹ä»¶ä¸¢å¤±çš„é—®é¢˜

### 3. ä¼˜åŒ– loop å‡½æ•°ï¼Œä¼˜å…ˆå¤„ç† signalCï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰

**ä¿®æ”¹ä½ç½®ï¼š** `strategy.go:203-218`

```go
func (s *Strategy) loop(loopCtx context.Context, tickC <-chan time.Time) {
    ticker := time.NewTicker(time.Duration(s.baseLoopTickMs()) * time.Millisecond)
    defer ticker.Stop()

    for {
        select {
        case <-loopCtx.Done():
            return
        case <-s.signalC:
            // ä¼˜å…ˆå¤„ç†ä»·æ ¼/è®¢å•äº‹ä»¶
            s.step(loopCtx, time.Now())
            // æ¸…ç©º ticker channelï¼Œé¿å…ç§¯å‹
            select {
            case <-ticker.C:
            default:
            }
        case <-ticker.C:
            // tick ä½œä¸ºä¿åº•ï¼Œç¡®ä¿å®šæœŸæ‰§è¡Œ
            s.step(loopCtx, time.Now())
        }
    }
}
```

**ç†ç”±ï¼š**
- signalC ä¿¡å·ä¼˜å…ˆå¤„ç†
- é¿å… tick ä¿¡å·ç§¯å‹
- æ›´åŠæ—¶å“åº”ä»·æ ¼å˜åŒ–

**æ³¨æ„ï¼š** è¿™ä¸ªä¼˜åŒ–æ˜¯å¯é€‰çš„ï¼Œå¦‚æœ signalC ç¼“å†²è¶³å¤Ÿå¤§ï¼Œå¯èƒ½ä¸éœ€è¦è¿™ä¸ªä¼˜åŒ–ã€‚

## å®æ–½ä¼˜å…ˆçº§

1. **é«˜ä¼˜å…ˆçº§**ï¼šæ–¹æ¡ˆ 2 + æ–¹æ¡ˆ 3ï¼ˆæ”¹è¿› step å‡½æ•°é€»è¾‘ + ä¼˜åŒ– loop å‡½æ•°ï¼‰
   - ç«‹å³è§£å†³ä»·æ ¼äº‹ä»¶ä¸¢å¤±é—®é¢˜
   - ç­–ç•¥å¯ä»¥ç»§ç»­å·¥ä½œ

2. **ä¸­ä¼˜å…ˆçº§**ï¼šæ–¹æ¡ˆ 1ï¼ˆå¢åŠ  signalC ç¼“å†²ï¼‰
   - å‡å°‘ä¿¡å·ä¸¢å¤±
   - å®ç°ç®€å•

3. **ä½ä¼˜å…ˆçº§**ï¼šæ–¹æ¡ˆ 4ï¼ˆæ”¹è¿›ä»·æ ¼äº‹ä»¶åˆå¹¶æœºåˆ¶ï¼‰
   - è¿›ä¸€æ­¥ä¼˜åŒ–äº‹ä»¶ç®¡ç†
   - éœ€è¦æ›´ç»†ç²’åº¦çš„å®ç°

## å®æ–½å»ºè®®

### ç«‹å³å®æ–½ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰

1. **å¢åŠ  signalC channel ç¼“å†²**ï¼ˆ5åˆ†é’Ÿï¼‰
   - ä¿®æ”¹ `Initialize()` æ–¹æ³•ä¸­çš„ channel åˆå§‹åŒ–
   - ä» `make(chan struct{}, 1)` æ”¹ä¸º `make(chan struct{}, 50)`

2. **ä¿å­˜å®Œæ•´çš„ market å¯¹è±¡**ï¼ˆ15åˆ†é’Ÿï¼‰
   - åœ¨ç­–ç•¥ç»“æ„ä½“ä¸­æ·»åŠ  `currentMarket *domain.Market` å­—æ®µ
   - åœ¨ `resetCycle()` ä¸­ä¿å­˜ market å¯¹è±¡
   - åœ¨ `step()` ä¸­ä½¿ç”¨ä¿å­˜çš„ market å¯¹è±¡ä½œä¸º fallback

### å¯é€‰ä¼˜åŒ–ï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰

3. **ä¼˜åŒ– loop å‡½æ•°**ï¼ˆ10åˆ†é’Ÿï¼‰
   - ä¼˜å…ˆå¤„ç† signalC ä¿¡å·
   - æ¸…ç©º ticker channelï¼Œé¿å…ç§¯å‹

### æµ‹è¯•éªŒè¯

4. **æµ‹è¯•åœºæ™¯**
   - ä»·æ ¼äº‹ä»¶æ­£å¸¸çš„æƒ…å†µ
   - ä»·æ ¼äº‹ä»¶ä¸¢å¤±çš„æƒ…å†µï¼ˆæ¨¡æ‹Ÿ channel æ»¡ï¼‰
   - tick ä¿¡å·è§¦å‘çš„æƒ…å†µ
   - å‘¨æœŸåˆ‡æ¢çš„æƒ…å†µ

## æ³¨æ„äº‹é¡¹

1. **çº¿ç¨‹å®‰å…¨**ï¼šä¿å­˜ market å¯¹è±¡æ—¶éœ€è¦æ³¨æ„çº¿ç¨‹å®‰å…¨ï¼ˆä½¿ç”¨ stateMu ä¿æŠ¤ï¼‰
2. **å†…å­˜ç®¡ç†**ï¼šä¿å­˜ market å¯¹è±¡æ—¶å¤åˆ¶ä¸€ä»½ï¼Œé¿å…å¤–éƒ¨å¤ç”¨æŒ‡é’ˆå¯¼è‡´ç«æ€
3. **æ€§èƒ½å½±å“**ï¼šæ”¹è¿›åéœ€è¦ç›‘æ§ step å‡½æ•°çš„æ‰§è¡Œé¢‘ç‡å’Œæ€§èƒ½
4. **å‘åå…¼å®¹**ï¼šç¡®ä¿æ”¹è¿›ä¸å½±å“ç°æœ‰åŠŸèƒ½
5. **æµ‹è¯•è¦†ç›–**ï¼šéœ€è¦å……åˆ†æµ‹è¯•å„ç§åœºæ™¯ï¼Œç‰¹åˆ«æ˜¯ä»·æ ¼äº‹ä»¶ä¸¢å¤±çš„æƒ…å†µ
