# CycleHedge策略开仓逻辑详解

**策略类型**: 市场中性套利（Complete Set Hedging）  
**核心思想**: 买入等量UP+DOWN，持有到结算获取$1/份，锁定确定收益

---

## 📋 目录

1. [开仓触发条件](#开仓触发条件)
2. [目标持仓计算](#目标持仓计算)
3. [开仓价格选择](#开仓价格选择)
4. [开仓数量计算](#开仓数量计算)
5. [开仓执行流程](#开仓执行流程)
6. [持仓平衡逻辑](#持仓平衡逻辑)
7. [风险控制](#风险控制)

---

## 🎯 开仓触发条件

### 1. 基本条件检查

**每次`step`函数调用时都会检查以下条件：**

```go
// 1. 市场过滤
if !strings.HasPrefix(m.Slug, marketSlugPrefix) {
    return  // 不是目标市场，不交易
}

// 2. 盘口质量检查（可选）
if EnableMarketQualityGate && mq.Score < minScore {
    return  // 盘口质量不达标，不交易
}

// 3. 盘口数据有效性
if yesBidC <= 0 || yesAskC <= 0 || noBidC <= 0 || noAskC <= 0 {
    return  // 盘口数据无效，不交易
}

// 4. Closeout窗口检查
if inCloseout && unhedged < MinUnhedgedShares {
    return  // 进入closeout且无裸露，停止开仓
}
```

### 2. 目标达成检查

**如果已达成目标，停止开仓：**

```go
// 计算最坏情况PnL
worstCasePnLUSDC = min(pnlUpWinUSDC, pnlDownWinUSDC)

// 目标检查
if worstCasePnLUSDC >= targetWorst {
    cancelMarketOrders()  // 撤掉挂单
    return  // 目标达成，停止开仓
}
```

### 3. 最大持仓限制

**如果达到最大单向持仓限制：**

```go
if maxShares >= MaxSingleSideShares {
    if unhedged < MinUnhedgedShares && worstCasePnLUSDC >= targetWorst {
        return  // 无裸露且目标达成，停止开仓
    }
    // 否则继续执行（允许补齐裸露）
}
```

---

## 💰 目标持仓计算

### 1. 目标Notional（资金规模）

**在周期开始时计算：**

```go
// 方式1: 固定Notional
if FixedNotionalUSDC > 0 {
    targetNotional = FixedNotionalUSDC
    // 但不能超过可用余额
    cap := balance * BalanceAllocationPct
    if targetNotional > cap {
        targetNotional = cap
    }
}

// 方式2: 按余额比例（默认）
else {
    targetNotional = max(MinNotionalUSDC, balance * BalanceAllocationPct)
    targetNotional = min(targetNotional, MaxNotionalUSDC)
}
```

**示例**:
- `FixedNotionalUSDC = 50 USDC`
- `BalanceAllocationPct = 0.8`
- `balance = 100 USDC`
- → `targetNotional = 50 USDC`（固定模式）

### 2. 目标Shares（持仓数量）

**根据选择的profit和targetNotional计算：**

```go
// 选择的profit（cents）
chosenProfit = chooseDynamicProfit(...)  // 例如：3c

// 成本 = 100 - profit
costCents = 100 - chosenProfit  // 100 - 3 = 97c

// 目标shares = notional / costPerShare
targetShares = targetNotional * 100.0 / costCents
// 例如：50 * 100 / 97 = 51.55 shares
```

**公式**:
```
targetShares = targetNotional × 100 / (100 - profitCents)
```

---

## 💵 开仓价格选择

### 1. 动态Profit选择

**核心函数**: `chooseDynamicProfit()`

**选择逻辑**:
1. **Profit范围**: `[ProfitMinCents, ProfitMaxCents]`（默认1-5c）
2. **对每个profit值**:
   - 调用`chooseMakerBids()`计算对应的UP/DOWN买价
   - 检查是否满足maker条件（`yesBid < yesAsk`, `noBid < noAsk`）
   - 计算评分：`score = profit - penalty × maxDistance`
3. **选择得分最高的profit**

**示例**:
```
盘口: UP(bid=48c ask=50c) DOWN(bid=50c ask=52c)

尝试profit=3c:
  - cost = 100 - 3 = 97c
  - 需要: yesBid + noBid = 97c
  - 选择: yesBid=48c, noBid=49c（贴近bestBid）
  - 评分: 3 - 0.3×0 = 3.0

尝试profit=5c:
  - cost = 100 - 5 = 95c
  - 需要: yesBid + noBid = 95c
  - 选择: yesBid=47c, noBid=48c（离bestBid更远）
  - 评分: 5 - 0.3×1 = 4.7

选择: profit=5c（得分更高）
```

### 2. Maker价格计算

**核心函数**: `chooseMakerBids()`

**约束条件**:
1. **Maker约束**: `yesBid < yesAsk`, `noBid < noAsk`
2. **成本约束**: `yesBid + noBid = 100 - profitCents`
3. **正价约束**: `yesBid >= 1`, `noBid >= 1`
4. **贴近盘口**: 尽量不低于`bestBid`

**算法**:
```go
targetSum = 100 - profitCents

// yesBid的可行区间
lb = max(1, targetSum - (noAsk - 1))  // 下界
ub = min(yesAsk - 1, targetSum - 1)   // 上界

// 尽量贴近bestBid
if yesBidC > lb {
    lb = yesBidC
}

// 选择lb（最贴近bestBid的价格）
chosenYesBid = lb
chosenNoBid = targetSum - chosenYesBid

// 确保noBid也不低于bestBid
if chosenNoBid < noBidC {
    chosenYesBid = targetSum - noBidC
    chosenNoBid = noBidC
}
```

---

## 📊 开仓数量计算

### 1. 需要开仓的数量

**计算逻辑**:

```go
// 当前持仓
upShares, downShares = currentTotals(marketSlug)

// 目标持仓（已计算）
targetShares = targetNotional * 100 / costCents

// 需要开仓的数量
needUp = max(0, targetShares - upShares)
needDown = max(0, targetShares - downShares)
```

**示例**:
```
targetShares = 51.55
upShares = 20.00
downShares = 20.00

needUp = max(0, 51.55 - 20.00) = 31.55
needDown = max(0, 51.55 - 20.00) = 31.55
```

### 2. 裸露风险处理

**如果已有裸露（单腿持仓）：**

```go
if unhedged >= MinUnhedgedShares {
    // 只补齐缺腿，不扩大总规模
    if upShares > downShares {
        needUp = 0  // UP多了，只补DOWN
    } else {
        needDown = 0  // DOWN多了，只补UP
    }
}
```

**示例**:
```
upShares = 30.00
downShares = 20.00
unhedged = 10.00 >= MinUnhedgedShares(5)

→ needUp = 0（不扩大UP）
→ needDown = 10.00（补齐DOWN）
```

### 3. 订单大小限制

**应用MaxOrderSizeShares限制：**

```go
if needUp > 0 {
    needUp = clampOrderSize(needUp)  // 限制到MaxOrderSizeShares
}
if needDown > 0 {
    needDown = clampOrderSize(needDown)
}
```

**示例**:
```
needUp = 31.55
MaxOrderSizeShares = 10

→ needUp = 10.00（被限制）
→ 需要多次下单才能达到目标
```

---

## 🚀 开仓执行流程

### 1. 下单前准备

```go
// 1. 撤掉旧挂单（避免多单堆叠）
if (needUp > 0 || needDown > 0) && (yesOrderID != "" || noOrderID != "") {
    cancelMarketOrdersThrottled()
    yesOrderID, noOrderID = "", ""
}

// 2. 检查订单大小
needUpOK = needUp > 0
needDownOK = needDown > 0
```

### 2. 下单执行

**并发下单（降低单腿成交风险）：**

```go
if needUpOK && needDownOK {
    // 并发下单两腿
    go placeYes()  // UP订单
    go placeNo()   // DOWN订单
    wait()
} else if needUpOK {
    placeYes()  // 只下UP
} else if needDownOK {
    placeNo()   // 只下DOWN
}
```

**订单参数**:
```go
// UP订单
Order{
    MarketSlug: marketSlug,
    AssetID: yesAssetID,
    TokenType: TokenTypeUp,
    Side: SideBuy,
    Price: yesPrice,      // chosenYesBidC
    Size: needUp,         // 计算出的数量
    OrderType: OrderTypeGTC,  // 挂单模式
}

// DOWN订单
Order{
    MarketSlug: marketSlug,
    AssetID: noAssetID,
    TokenType: TokenTypeDown,
    Side: SideBuy,
    Price: noPrice,       // chosenNoBidC
    Size: needDown,       // 计算出的数量
    OrderType: OrderTypeGTC,  // 挂单模式
}
```

### 3. 下单后处理

```go
// 记录订单ID
if ord != nil {
    yesOrderID = ord.OrderID  // 或 noOrderID
    stats.OrdersPlacedYes++   // 或 OrdersPlacedNo++
}

// 更新报价时间（用于requote节流）
lastQuoteAt = now
```

---

## ⚖️ 持仓平衡逻辑

### 1. 理想状态

**目标**: UP和DOWN持仓完全平衡

```
upShares = downShares = targetShares
unhedged = 0
```

### 2. 单腿成交处理

**当只有一腿成交时（出现裸露）：**

```go
unhedged = maxShares - minShares

if unhedged >= MinUnhedgedShares {
    // 进入补齐逻辑
    // 1. 先尝试maker补齐（bestBid挂单）
    // 2. 超时后升级到taker补齐或回平
}
```

**补齐策略**:
1. **Maker补齐**（优先）:
   - 在缺腿的`bestBid`挂单
   - 超时后逐步提高价格（`bid + bump`）
   - 尾盘可贴到`ask-1`（仍保持maker）

2. **Taker补齐**（超时后）:
   - 直接吃`ask`价格补齐
   - 需要满足`minProfitAfterComplete`门槛

3. **回平**（无法补齐时）:
   - 卖出多余的一腿
   - 结束裸露风险

### 3. 持仓平衡度

**计算公式**:
```go
minShares = min(upShares, downShares)
maxShares = max(upShares, downShares)
unhedged = maxShares - minShares
balanceRatio = minShares / maxShares  // 平衡度（0-1）
```

**示例**:
```
upShares = 30.00
downShares = 30.00
→ balanceRatio = 30.00 / 30.00 = 100%（完美平衡）

upShares = 30.00
downShares = 28.00
→ balanceRatio = 28.00 / 30.00 = 93.3%（良好平衡）
```

---

## 🛡️ 风险控制

### 1. 最大单向持仓限制

**目的**: 防止单腿持仓过大

```go
if maxShares >= MaxSingleSideShares {
    // 停止扩大规模
    // 只允许补齐裸露
    if unhedged < MinUnhedgedShares && worstCasePnLUSDC >= targetWorst {
        return  // 停止开仓
    }
}
```

### 2. 裸露超时控制

**目的**: 防止单腿持仓时间过长

```go
if unhedged >= MinUnhedgedShares {
    age = now - firstFillAt
    
    if age >= timeoutSeconds {
        // 超时：强制补齐或回平
        if completeProfit >= flattenProfit {
            takerComplete()  // 补齐
        } else {
            flatten()  // 回平
        }
    }
}
```

### 3. 裸露预算控制

**目的**: 防止裸露过大

```go
budget = dynamicUnhedgedBudgetShares(remainingSeconds)

if unhedged >= budget {
    force = true  // 强制补齐或回平
    // 不等待超时，立即处理
}
```

### 4. Closeout窗口

**目的**: 尾盘停止新增持仓

```go
if remainingSeconds <= EntryCutoffSeconds {
    inCloseout = true
    
    if unhedged < MinUnhedgedShares {
        return  // 无裸露，停止开仓
    }
    // 有裸露：继续补齐逻辑
}
```

---

## 📈 完整开仓流程图

```
┌─────────────────────────────────────┐
│ step() 函数调用                     │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 1. 市场过滤和盘口质量检查           │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. 读取当前持仓                     │
│    upShares, downShares             │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. 目标达成检查                     │
│    worstCasePnL >= targetWorst?     │
└──────────────┬──────────────────────┘
               │
        ┌──────┴──────┐
        │             │
       Yes           No
        │             │
        ▼             ▼
┌───────────┐  ┌──────────────────────┐
│ 撤单停止  │  │ 4. 检查是否有裸露     │
└───────────┘  └──────────┬───────────┘
                          │
                    ┌─────┴─────┐
                    │           │
                  Yes          No
                    │           │
                    ▼           ▼
        ┌──────────────────┐  ┌──────────────────────┐
        │ 5. 补齐逻辑      │  │ 6. 正常建仓逻辑      │
        │ - Maker补齐      │  │ - 选择动态profit     │
        │ - Taker补齐      │  │ - 计算targetShares   │
        │ - 回平           │  │ - 计算needUp/needDown│
        └──────────────────┘  └──────────┬───────────┘
                                         │
                                         ▼
                            ┌────────────────────────┐
                            │ 7. 下单执行            │
                            │ - 撤旧单               │
                            │ - 并发下单UP/DOWN      │
                            │ - 记录订单ID           │
                            └────────────────────────┘
```

---

## 💡 关键设计特点

### 1. Maker优先策略

- **目标**: 通过挂maker订单获取利润，避免吃单成本
- **价格**: 选择`bestBid`或略高于`bestBid`的价格
- **类型**: `OrderTypeGTC`（Good Till Cancel）

### 2. 动态Profit选择

- **范围**: `[ProfitMinCents, ProfitMaxCents]`
- **评分**: `score = profit - penalty × distance`
- **选择**: 得分最高的profit（平衡收益和成交概率）

### 3. 持续建仓

- **机制**: 每次`step`检查持仓，持续下单直到达到`targetShares`
- **限制**: 受`MaxOrderSizeShares`限制，可能需要多次下单
- **节流**: 达到目标后应用`requote`节流，避免频繁重新报价

### 4. 风险控制

- **裸露超时**: 单腿持仓超时后强制补齐或回平
- **预算控制**: 裸露超过预算时立即处理
- **最大持仓**: 限制单边持仓上限

---

## 📝 配置参数说明

### 核心参数

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `FixedNotionalUSDC` | 固定资金规模 | 0（使用余额比例） |
| `BalanceAllocationPct` | 余额使用比例 | 0.8 |
| `ProfitMinCents` | 最小锁利 | 1c |
| `ProfitMaxCents` | 最大锁利 | 5c |
| `MaxOrderSizeShares` | 单笔最大数量 | 20 |
| `MaxSingleSideShares` | 最大单向持仓 | 6000 |
| `MinUnhedgedShares` | 最小触发裸露 | 1 |
| `UnhedgedTimeoutSeconds` | 裸露超时 | 10s |

### 风险控制参数

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `EntryCutoffSeconds` | Closeout窗口 | 25s |
| `MaxUnhedgedSharesBudget` | 裸露预算 | 0（关闭） |
| `MinProfitAfterCompleteCents` | 补齐最小利润 | 0 |
| `EnableMakerSupplement` | 启用Maker补齐 | true |

---

## 🎯 总结

### 开仓逻辑核心

1. **目标**: 达到`targetShares`的UP和DOWN持仓
2. **方式**: 通过maker订单持续建仓
3. **价格**: 动态选择profit，计算对应的UP/DOWN买价
4. **数量**: `needUp = max(0, targetShares - upShares)`
5. **执行**: 并发下单UP和DOWN，降低单腿成交风险

### 关键特点

- ✅ **Maker优先**: 通过挂单获取利润，避免吃单成本
- ✅ **持续建仓**: 每次step检查持仓，持续下单直到目标
- ✅ **风险控制**: 裸露超时、预算控制、最大持仓限制
- ✅ **动态调整**: 根据剩余时间和盘口情况动态调整策略

---

**文档生成时间**: 2025-12-30  
**策略版本**: CycleHedge v1.0
