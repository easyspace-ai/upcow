# CycleHedge 策略问题分析报告

## 📊 预期 vs 实际对比

### 配置参数
- `fixedNotionalUSDC`: **50 USDC**
- `MaxOrderSizeShares`: **10 shares**
- `MinUnhedgedShares`: **5 shares**
- `RequoteMs`: **800ms** (默认)

### 实际执行结果

| 指标 | 预期 | 实际 | 差异 |
|------|------|------|------|
| targetNotional | 50 USDC | 20.89 USDC | ⚠️ 被余额限制 |
| 目标 shares | 52.08 | 21.76 | ⚠️ 被余额限制 |
| 单次下单量 | 21.76 | 10.00 | ⚠️ 被MaxOrderSizeShares限制 |
| 需要下单次数 | 1次 | 2.2次 | ⚠️ 需要多次下单 |
| 实际下单次数 | 多次 | 1次 | ❌ **问题：只下了一次** |
| Quote次数 | 多次 | 3次（周期1）1次（周期2） | ⚠️ 频率偏低 |

## 🔍 问题分析

### 问题 1：targetNotional 被余额限制 ⚠️

**原因：**
```go
// strategy.go:1266-1278
if s.FixedNotionalUSDC > 0 {
    tn = s.FixedNotionalUSDC  // 50
    // 安全护栏：固定 notional 不应超过可用余额
    cap := bal * alloc  // 20.89 * 1 = 20.89
    if tn > cap {
        tn = cap  // 50 > 20.89，被限制到20.89
    }
}
```

**影响：**
- 配置的50 USDC无法使用，被限制到20.89 USDC
- 目标shares从52.08降到21.76

**解决方案：**
- 这是**正常的风控机制**，防止资金不足
- 如果需要使用50 USDC，需要确保余额 >= 50 USDC

---

### 问题 2：订单大小被MaxOrderSizeShares限制 ⚠️

**原因：**
```go
// strategy.go:1181-1190
func (s *Strategy) clampOrderSize(size float64) float64 {
    limit := s.MaxOrderSizeShares  // 10
    if limit > 0 && size > limit {
        return limit  // 21.76 > 10，被限制到10
    }
    return size
}
```

**影响：**
- 目标shares=21.76，但单次只能下10 shares
- 需要至少3次下单才能达到目标（10+10+1.76）
- 但实际只下了1次（10+10）

**解决方案：**
- 这是**正常的风控机制**，防止单笔订单过大
- 策略应该**持续下单**直到达到targetShares

---

### 问题 3：requote节流导致下单频率过低 ❌ **核心问题**

**原因：**
```go
// strategy.go:860-877
if !inCloseout {
    requoteMs := s.dynamicRequoteMs(remainingSeconds)  // 默认800ms
    if !lastQ.IsZero() && timeSinceLastQuote < time.Duration(requoteMs)*time.Millisecond {
        log.Debugf("requote节流: ...")
        return  // ⚠️ 直接返回，不执行下单逻辑
    }
    s.lastQuoteAt = now
}
```

**问题分析：**
1. **requote节流逻辑位置错误**：
   - requote节流在**下单之前**检查
   - 如果距离上次quote < 800ms，直接return，**不执行下单逻辑**
   - 这导致即使订单成交了，也不会立即继续下单

2. **lastQuoteAt更新时机错误**：
   - `lastQuoteAt`在requote检查**之后**更新
   - 但如果因为节流return了，`lastQuoteAt`不会更新
   - 这导致后续的step调用也会被节流

3. **订单成交后没有继续下单**：
   - 订单成交后，持仓增加（upShares/downShares增加）
   - 但`needUp`和`needDown`会减少
   - 如果`needUp < MinUnhedgedShares`或`needDown < MinUnhedgedShares`，不会下单
   - 同时，requote节流也会阻止继续下单

**影响：**
- step执行频率低（周期1767025800只有2次）
- 订单只下了一次，没有持续下单达到目标
- 目标shares=21.76，但只下了10 shares

---

### 问题 4：订单大小检查逻辑问题 ⚠️

**原因：**
```go
// strategy.go:983-1002
needUpOK := needUp >= s.MinUnhedgedShares  // needUp=10, MinUnhedgedShares=5, OK
needDownOK := needDown >= s.MinUnhedgedShares  // needDown=10, MinUnhedgedShares=5, OK

if needUpOK {
    needUp = s.clampOrderSize(needUp)  // 10 -> 10 (未限制)
    needUpOK = needUp >= s.MinUnhedgedShares  // 10 >= 5, OK
}
if needDownOK {
    needDown = s.clampOrderSize(needDown)  // 10 -> 10 (未限制)
    needDownOK = needDown >= s.MinUnhedgedShares  // 10 >= 5, OK
}

if !needUpOK && !needDownOK {
    log.Debugf("订单大小不足: ...")
    // ⚠️ 但没有return，继续执行
}
```

**问题：**
- 如果`needUp < MinUnhedgedShares`或`needDown < MinUnhedgedShares`，不会下单
- 但策略应该**持续下单**直到达到targetShares
- 当前逻辑：如果`needUp < 5`或`needDown < 5`，就不会下单，导致无法达到目标

---

### 问题 5：订单成交后没有继续下单 ❌ **核心问题**

**原因分析：**
1. **订单成交后，持仓增加**：
   - upShares/downShares增加
   - `needUp = max(0, shares - upShares)`减少
   - `needDown = max(0, shares - downShares)`减少

2. **requote节流阻止继续下单**：
   - 订单成交后，`lastQuoteAt`已经更新
   - 下次step调用时，如果距离`lastQuoteAt < 800ms`，会被节流
   - 即使`needUp > 0`或`needDown > 0`，也不会下单

3. **订单大小检查阻止继续下单**：
   - 如果`needUp < MinUnhedgedShares`（5），不会下单
   - 例如：`needUp = 1.76 < 5`，不会下单

**影响：**
- 目标shares=21.76，但只下了10 shares
- 剩余11.76 shares没有下单
- 策略无法达到目标持仓

---

## 🎯 根本原因总结

### 核心问题：requote节流逻辑阻止了持续下单

1. **requote节流位置错误**：
   - 在**下单之前**检查，如果节流就直接return
   - 这导致即使需要继续下单，也会被节流阻止

2. **订单成交后没有触发继续下单**：
   - 订单成交后，持仓增加，`needUp/needDown`减少
   - 但requote节流会阻止继续下单
   - 导致无法达到targetShares

3. **订单大小检查过于严格**：
   - `needUp < MinUnhedgedShares`时不会下单
   - 但策略应该持续下单直到达到targetShares

---

## 💡 解决方案

### 方案 1：修复 requote 节流逻辑（推荐）⭐

**问题：** requote节流在**下单之前**检查，导致即使需要继续下单也会被节流

**解决方案：**
1. **requote节流应该只影响"重新报价"**，不应该阻止"继续下单"
2. **如果订单已成交，应该立即继续下单**，不受requote节流限制
3. **只有在"没有持仓变化"时才应用requote节流**

**修改建议：**
```go
// 修改前：requote节流在正常建仓之前
if !inCloseout {
    requoteMs := s.dynamicRequoteMs(remainingSeconds)
    if !lastQ.IsZero() && timeSinceLastQuote < time.Duration(requoteMs)*time.Millisecond {
        return  // ⚠️ 直接返回，不执行下单逻辑
    }
    s.lastQuoteAt = now
}

// 修改后：requote节流只影响"重新报价"，不影响"继续下单"
// 检查是否需要继续下单（持仓未达到目标）
needMore := (needUp >= s.MinUnhedgedShares || needDown >= s.MinUnhedgedShares)
if !inCloseout && !needMore {
    // 只有在"不需要继续下单"时才应用requote节流
    requoteMs := s.dynamicRequoteMs(remainingSeconds)
    if !lastQ.IsZero() && timeSinceLastQuote < time.Duration(requoteMs)*time.Millisecond {
        return  // 可以节流，因为不需要下单
    }
    s.lastQuoteAt = now
}
```

---

### 方案 2：订单成交后立即触发继续下单

**问题：** 订单成交后，没有立即触发继续下单

**解决方案：**
1. **订单成交后，通过OnOrderUpdate触发step**
2. **step检查持仓，如果未达到目标，继续下单**
3. **不受requote节流限制**（因为持仓变化了）

**当前实现：**
```go
func (s *Strategy) OnOrderUpdate(_ context.Context, order *domain.Order) error {
    select {
    case s.orderC <- order:
    default:
    }
    common.TrySignal(s.signalC)  // ✅ 已经发送信号
    return nil
}
```

**问题：** signalC可能丢失，或者step被requote节流阻止

---

### 方案 3：放宽订单大小检查

**问题：** `needUp < MinUnhedgedShares`时不会下单

**解决方案：**
1. **如果`needUp > 0`或`needDown > 0`，应该继续下单**
2. **即使`needUp < MinUnhedgedShares`，也应该下单**（如果目标是达到targetShares）
3. **MinUnhedgedShares应该只用于"裸露风险控制"，不应该用于"建仓限制"**

**修改建议：**
```go
// 修改前：needUp < MinUnhedgedShares时不下单
needUpOK := needUp >= s.MinUnhedgedShares
if !needUpOK {
    // 不下单
}

// 修改后：如果needUp > 0，就应该下单（即使 < MinUnhedgedShares）
needUpOK := needUp > 0  // 只要需要，就下单
// MinUnhedgedShares只用于裸露风险控制，不用于建仓限制
```

---

### 方案 4：修复 targetNotional 计算（如果需要）

**问题：** targetNotional被余额限制

**解决方案：**
- 这是**正常的风控机制**，不需要修改
- 如果需要使用50 USDC，需要确保余额 >= 50 USDC
- 或者调整`BalanceAllocationPct`配置

---

## 📋 优先级修复建议

### 🔴 高优先级（立即修复）

1. **修复 requote 节流逻辑**：
   - requote节流不应该阻止"继续下单"
   - 只有在"不需要继续下单"时才应用requote节流

2. **修复订单大小检查**：
   - `needUp > 0`或`needDown > 0`时应该下单
   - MinUnhedgedShares只用于裸露风险控制

### 🟡 中优先级（优化）

3. **增加订单成交后的继续下单逻辑**：
   - 订单成交后，立即检查是否需要继续下单
   - 不受requote节流限制

4. **增加日志**：
   - 记录requote节流的原因
   - 记录为什么没有继续下单

### 🟢 低优先级（可选）

5. **优化targetNotional计算**：
   - 如果需要使用50 USDC，确保余额充足
   - 或者调整配置参数

---

## 🔧 具体修改建议

### 修改 1：修复 requote 节流逻辑

**文件：** `strategy.go:860-877`

**修改前：**
```go
// 动态 requote：在 closeout 外，按剩余时间加速报价刷新
if !inCloseout {
    requoteMs := s.dynamicRequoteMs(remainingSeconds)
    if requoteMs > 0 {
        s.stateMu.Lock()
        lastQ := s.lastQuoteAt
        timeSinceLastQuote := now.Sub(lastQ)
        s.stateMu.Unlock()
        if !lastQ.IsZero() && timeSinceLastQuote < time.Duration(requoteMs)*time.Millisecond {
            log.Debugf("requote节流: ...")
            return  // ⚠️ 直接返回，不执行下单逻辑
        }
        s.stateMu.Lock()
        s.lastQuoteAt = now
        s.stateMu.Unlock()
    }
}
```

**修改后：**
```go
// 动态 requote：在 closeout 外，按剩余时间加速报价刷新
// ⚠️ 注意：requote节流不应该阻止"继续下单"，只应该阻止"重新报价"
// 如果持仓未达到目标（needUp > 0 或 needDown > 0），应该继续下单，不受requote节流限制
if !inCloseout {
    requoteMs := s.dynamicRequoteMs(remainingSeconds)
    if requoteMs > 0 {
        s.stateMu.Lock()
        lastQ := s.lastQuoteAt
        timeSinceLastQuote := now.Sub(lastQ)
        s.stateMu.Unlock()
        
        // 检查是否需要继续下单（持仓未达到目标）
        // 注意：这里先计算needUp/needDown，但实际计算在后面
        // 所以先用一个简单的检查：如果lastQuoteAt很久没更新，说明可能需要继续下单
        needContinueOrdering := lastQ.IsZero() || timeSinceLastQuote > time.Duration(requoteMs)*time.Millisecond
        
        if !needContinueOrdering && !lastQ.IsZero() && timeSinceLastQuote < time.Duration(requoteMs)*time.Millisecond {
            log.Debugf("🔍 [%s] requote节流: market=%s timeSinceLastQuote=%v < requoteMs=%dms", 
                ID, m.Slug, timeSinceLastQuote, requoteMs)
            // ⚠️ 不直接return，继续执行，让后续逻辑判断是否需要下单
            // 如果needUp/needDown > 0，仍然应该下单
        } else {
            // 更新lastQuoteAt（只有在实际需要下单时才更新）
            s.stateMu.Lock()
            s.lastQuoteAt = now
            s.stateMu.Unlock()
        }
    }
}
```

**更好的方案：**
```go
// 动态 requote：在 closeout 外，按剩余时间加速报价刷新
// ⚠️ 关键修复：requote节流应该移到"下单之后"，只影响"重新报价"，不影响"继续下单"
// 先执行下单逻辑，然后在最后更新lastQuoteAt
if !inCloseout {
    requoteMs := s.dynamicRequoteMs(remainingSeconds)
    if requoteMs > 0 {
        s.stateMu.Lock()
        lastQ := s.lastQuoteAt
        timeSinceLastQuote := now.Sub(lastQ)
        s.stateMu.Unlock()
        
        // ⚠️ 修复：只有在"不需要继续下单"时才应用requote节流
        // 先计算needUp/needDown（需要移到前面）
        // 如果needUp > 0 或 needDown > 0，说明需要继续下单，不受requote节流限制
        // 这里先不检查，继续执行下单逻辑
        // 在最后更新lastQuoteAt时再检查
    }
}

// ... 执行下单逻辑 ...

// 在下单之后更新lastQuoteAt
if !inCloseout {
    requoteMs := s.dynamicRequoteMs(remainingSeconds)
    if requoteMs > 0 {
        s.stateMu.Lock()
        s.lastQuoteAt = now
        s.stateMu.Unlock()
    }
}
```

---

### 修改 2：修复订单大小检查

**文件：** `strategy.go:983-1002`

**修改前：**
```go
needUpOK := needUp >= s.MinUnhedgedShares
needDownOK := needDown >= s.MinUnhedgedShares
if needUpOK {
    needUp = s.clampOrderSize(needUp)
    needUpOK = needUp >= s.MinUnhedgedShares
}
if needDownOK {
    needDown = s.clampOrderSize(needDown)
    needDownOK = needDown >= s.MinUnhedgedShares
}
if !needUpOK && !needDownOK {
    log.Debugf("订单大小不足: ...")
}
```

**修改后：**
```go
// ⚠️ 修复：MinUnhedgedShares只用于"裸露风险控制"，不用于"建仓限制"
// 如果needUp > 0 或 needDown > 0，就应该下单（即使 < MinUnhedgedShares）
needUpOK := needUp > 0  // 只要需要，就下单
needDownOK := needDown > 0  // 只要需要，就下单

if needUpOK {
    needUp = s.clampOrderSize(needUp)
    needUpOK = needUp > 0  // 检查clamp后是否还有剩余
}
if needDownOK {
    needDown = s.clampOrderSize(needDown)
    needDownOK = needDown > 0  // 检查clamp后是否还有剩余
}

if !needUpOK && !needDownOK {
    log.Debugf("🔍 [%s] 订单大小不足: market=%s needUp=%.2f needDown=%.2f", 
        ID, m.Slug, needUp, needDown)
    // ⚠️ 不return，继续执行（可能还有其他逻辑）
}
```

---

## 📊 预期修复效果

### 修复前
- 目标shares: 21.76
- 实际下单: 10 shares（1次）
- 完成度: 46%

### 修复后（预期）
- 目标shares: 21.76
- 实际下单: 21.76 shares（3次：10+10+1.76）
- 完成度: 100%

---

## 🎯 总结

### 核心问题
1. **requote节流逻辑阻止了持续下单**（最严重）
2. **订单大小检查过于严格**（阻止了小单）
3. **targetNotional被余额限制**（正常风控，但影响订单量）

### 修复优先级
1. 🔴 **立即修复**：requote节流逻辑
2. 🔴 **立即修复**：订单大小检查
3. 🟡 **优化**：增加订单成交后的继续下单逻辑

### 预期效果
- 订单量达到目标（21.76 shares）
- 持续下单直到达到targetShares
- 不受requote节流影响（如果持仓未达到目标）
