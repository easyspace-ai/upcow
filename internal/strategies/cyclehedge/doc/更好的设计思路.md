# CycleHedge 策略更好的设计思路

## 当前问题分析

### 核心问题
1. **信号丢失严重**：52,038次失败 vs 50次成功（99.9%丢失率）
2. **事件合并导致数据丢失**：step 函数每次清空 `s.latest`，导致价格事件丢失
3. **依赖 channel 传递**：高频价格更新 → channel 满 → 信号丢失
4. **tick 作为保底**：虽然有效，但频率可能不够高，响应延迟

### 根本原因
- **设计模式不匹配**：cyclehedge 需要定期执行复杂逻辑，但事件驱动模式不适合高频更新
- **状态管理混乱**：价格事件存储在 `s.latest`，step 清空后丢失
- **channel 容量限制**：即使增加到50，在高频更新下仍然不够

## 更好的设计思路

### 方案 1：状态快照模式（推荐）⭐

**核心思想**：OnPriceChanged 直接更新状态，step 读取状态快照，不依赖事件合并。

#### 设计要点

1. **状态原子更新**：
   ```go
   type priceSnapshot struct {
       UpPrice   *events.PriceChangedEvent
       DownPrice *events.PriceChangedEvent
       Market    *domain.Market
       UpdatedAt time.Time
   }
   
   type Strategy struct {
       priceMu sync.RWMutex
       priceSnapshot priceSnapshot  // 原子状态快照
       // ...
   }
   ```

2. **OnPriceChanged 直接更新状态**：
   ```go
   func (s *Strategy) OnPriceChanged(ctx context.Context, e *events.PriceChangedEvent) error {
       if e == nil || e.Market == nil {
           return nil
       }
       
       // 原子更新状态快照
       s.priceMu.Lock()
       if e.TokenType == domain.TokenTypeUp {
           s.priceSnapshot.UpPrice = e
       } else if e.TokenType == domain.TokenTypeDown {
           s.priceSnapshot.DownPrice = e
       }
       // 更新 market（取最新的）
       if s.priceSnapshot.Market == nil || 
          s.priceSnapshot.Market.Slug != e.Market.Slug {
           cp := *e.Market
           s.priceSnapshot.Market = &cp
       }
       s.priceSnapshot.UpdatedAt = time.Now()
       s.priceMu.Unlock()
       
       // 可选：只在关键变化时发送信号（如价格变化超过阈值）
       // 或者完全依赖 tick，不发送信号
       return nil
   }
   ```

3. **step 函数读取状态快照**：
   ```go
   func (s *Strategy) step(ctx context.Context, now time.Time) {
       // 读取状态快照（原子操作）
       s.priceMu.RLock()
       snapshot := s.priceSnapshot  // 复制快照
       s.priceMu.RUnlock()
       
       // 使用快照，不依赖事件合并
       if snapshot.Market == nil {
           return
       }
       
       // 继续执行后续逻辑...
   }
   ```

#### 优势
- ✅ **零信号丢失**：不依赖 channel，状态直接更新
- ✅ **数据不丢失**：状态快照保留最新数据
- ✅ **简单高效**：不需要事件合并逻辑
- ✅ **响应及时**：tick 频率可以设置更高（如50ms）

#### 劣势
- ⚠️ **内存占用**：保留价格事件对象（但很小）
- ⚠️ **需要调整**：需要重构现有代码

---

### 方案 2：混合模式（事件驱动 + 状态快照）

**核心思想**：OnPriceChanged 更新状态 + 发送信号，step 读取状态快照。

#### 设计要点

1. **保留 signalC，但只用于"重要变化"**：
   ```go
   func (s *Strategy) OnPriceChanged(ctx context.Context, e *events.PriceChangedEvent) error {
       // 更新状态快照（同方案1）
       s.updatePriceSnapshot(e)
       
       // 只在价格变化超过阈值时发送信号
       if s.shouldTriggerStep(e) {
           select {
           case s.signalC <- struct{}{}:
           default:
               // 信号丢失也无所谓，tick 会保底
           }
       }
       return nil
   }
   
   func (s *Strategy) shouldTriggerStep(e *events.PriceChangedEvent) bool {
       // 例如：价格变化超过1c，或者有新的 market
       // 或者：UP/DOWN 价格都更新了
       return true  // 简化：每次都触发
   }
   ```

2. **step 函数读取状态快照**（同方案1）

#### 优势
- ✅ **减少信号丢失**：只在重要变化时发送
- ✅ **保留事件驱动**：关键变化可以立即响应
- ✅ **tick 保底**：确保定期执行

#### 劣势
- ⚠️ **复杂度增加**：需要判断"重要变化"
- ⚠️ **仍然可能丢失**：channel 满时仍会丢失

---

### 方案 3：批量处理模式

**核心思想**：收集一段时间内的价格事件，批量处理。

#### 设计要点

1. **时间窗口收集**：
   ```go
   type Strategy struct {
       priceMu sync.Mutex
       priceWindow []*events.PriceChangedEvent  // 时间窗口内的价格事件
       windowStart time.Time
       windowDuration time.Duration  // 如 100ms
   }
   ```

2. **OnPriceChanged 收集事件**：
   ```go
   func (s *Strategy) OnPriceChanged(ctx context.Context, e *events.PriceChangedEvent) error {
       s.priceMu.Lock()
       s.priceWindow = append(s.priceWindow, e)
       // 如果窗口过期，触发处理
       if time.Since(s.windowStart) > s.windowDuration {
           go s.processPriceWindow()
           s.priceWindow = nil
           s.windowStart = time.Now()
       }
       s.priceMu.Unlock()
       return nil
   }
   ```

3. **批量处理**：
   ```go
   func (s *Strategy) processPriceWindow() {
       // 合并窗口内的价格事件
       // 调用 step
   }
   ```

#### 优势
- ✅ **减少处理频率**：批量处理，减少 step 调用
- ✅ **保留所有事件**：窗口内的所有事件都保留

#### 劣势
- ⚠️ **延迟增加**：需要等待窗口时间
- ⚠️ **复杂度高**：需要管理时间窗口
- ⚠️ **不适合实时交易**：延迟可能影响交易时机

---

### 方案 4：完全事件驱动（参考 updownthreshold）

**核心思想**：完全移除 loop/step，在 OnPriceChanged 中直接处理。

#### 设计要点

1. **OnPriceChanged 直接处理**：
   ```go
   func (s *Strategy) OnPriceChanged(ctx context.Context, e *events.PriceChangedEvent) error {
       // 直接调用交易逻辑
       return s.processTrading(ctx, e.Market)
   }
   ```

2. **移除 loop/step**：
   - 不需要 signalC
   - 不需要 tick
   - 不需要事件合并

#### 优势
- ✅ **最简单**：完全事件驱动
- ✅ **零延迟**：价格更新立即处理
- ✅ **无信号丢失**：不依赖 channel

#### 劣势
- ⚠️ **不适合复杂逻辑**：cyclehedge 需要定期执行（如检查持仓、平仓等）
- ⚠️ **需要重构**：需要将 step 逻辑拆分到不同函数

---

## 推荐方案：方案 1（状态快照模式）

### 实施步骤

1. **添加状态快照结构**：
   ```go
   type priceSnapshot struct {
       UpPrice   *events.PriceChangedEvent
       DownPrice *events.PriceChangedEvent
       Market    *domain.Market
       UpdatedAt time.Time
   }
   ```

2. **修改 OnPriceChanged**：
   - 移除 `s.latest` 和事件合并逻辑
   - 直接更新 `priceSnapshot`
   - 可选：移除 signalC 发送（完全依赖 tick）

3. **修改 step 函数**：
   - 移除事件合并逻辑
   - 读取 `priceSnapshot` 快照
   - 使用快照数据继续执行

4. **优化 tick 频率**：
   - 可以设置更高的频率（如50ms），因为不再依赖 signalC

### 代码示例

```go
// 1. 添加状态快照
type Strategy struct {
    priceMu sync.RWMutex
    priceSnapshot priceSnapshot  // 新增
    
    // 移除或保留 signalC（可选）
    signalC chan struct{}
    // ...
}

// 2. OnPriceChanged 更新状态
func (s *Strategy) OnPriceChanged(ctx context.Context, e *events.PriceChangedEvent) error {
    if e == nil || e.Market == nil {
        return nil
    }
    
    // 更新状态快照
    s.priceMu.Lock()
    if e.TokenType == domain.TokenTypeUp {
        s.priceSnapshot.UpPrice = e
    } else if e.TokenType == domain.TokenTypeDown {
        s.priceSnapshot.DownPrice = e
    }
    if s.priceSnapshot.Market == nil || 
       s.priceSnapshot.Market.Slug != e.Market.Slug {
        cp := *e.Market
        s.priceSnapshot.Market = &cp
    }
    s.priceSnapshot.UpdatedAt = time.Now()
    s.priceMu.Unlock()
    
    // 可选：发送信号（但不再必需）
    select {
    case s.signalC <- struct{}{}:
    default:
    }
    return nil
}

// 3. step 函数读取快照
func (s *Strategy) step(ctx context.Context, now time.Time) {
    // 读取状态快照
    s.priceMu.RLock()
    snapshot := s.priceSnapshot  // 复制
    s.priceMu.RUnlock()
    
    if snapshot.Market == nil {
        return
    }
    
    // 使用快照数据继续执行...
    evUp := snapshot.UpPrice
    evDown := snapshot.DownPrice
    m := snapshot.Market
    
    // 继续后续逻辑...
}
```

## 对比总结

| 方案 | 信号丢失 | 数据丢失 | 复杂度 | 响应速度 | 推荐度 |
|------|---------|---------|--------|---------|--------|
| 当前方案 | ❌ 99.9% | ❌ 是 | 中 | 慢 | ⭐ |
| 方案1：状态快照 | ✅ 0% | ✅ 否 | 低 | 快 | ⭐⭐⭐⭐⭐ |
| 方案2：混合模式 | ⚠️ 部分 | ✅ 否 | 中 | 快 | ⭐⭐⭐⭐ |
| 方案3：批量处理 | ✅ 0% | ✅ 否 | 高 | 慢 | ⭐⭐ |
| 方案4：完全事件驱动 | ✅ 0% | ✅ 否 | 低 | 最快 | ⭐⭐⭐ |

## 最终建议

**推荐实施方案 1（状态快照模式）**，原因：
1. ✅ **彻底解决信号丢失问题**：不依赖 channel
2. ✅ **数据不丢失**：状态快照保留最新数据
3. ✅ **简单高效**：代码更清晰，性能更好
4. ✅ **易于实施**：改动较小，风险低
5. ✅ **保留 tick 机制**：可以设置更高频率，确保及时响应
