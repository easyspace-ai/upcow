# CycleHedge 策略问题诊断报告
**分析时间**: 2025-12-30  
**日志文件**: btc-updown-15m-1767033000.log

## 🔍 问题1：Step函数调用次数少

### 现象
- **step函数调用**：3次
- **signalC信号触发**：2次
- **tick信号触发**：0次
- **价格更新**：198,070次

### 代码逻辑分析

**Step函数调用机制**：
```go
// strategy.go:237-266
func (s *Strategy) loop(loopCtx context.Context, tickC <-chan time.Time) {
    for {
        select {
        case <-loopCtx.Done():
            return
        case <-s.signalC:  // 价格/订单事件触发
            s.step(loopCtx, now)
        case <-tickC:      // 定时tick触发
            s.step(loopCtx, now)
        }
    }
}
```

**baseLoopTickMs配置**：
```go
// strategy.go:1614-1625
func (s *Strategy) baseLoopTickMs() int {
    ms := s.RequoteMs  // 默认800ms
    if ms < 200 {
        return ms
    }
    return 200  // 最小200ms
}
```

**价格更新触发signalC**：
```go
// strategy.go:180-222
func (s *Strategy) OnPriceChanged(ctx context.Context, e *events.PriceChangedEvent) error {
    // 更新价格快照
    // ...
    select {
    case s.signalC <- struct{}{}:
    default:
        // 信号丢失也无所谓，tick 会保底执行
    }
    return nil
}
```

### 问题分析

**可能原因**：
1. **Loop可能没有正常启动**：
   - tick触发：0次（说明tickC可能没有正常发送）
   - 但signalC触发：2次（说明loop在运行）
   - 可能loop启动后很快就退出了

2. **价格更新没有触发signalC**：
   - 价格更新：198,070次
   - signalC触发：只有2次
   - 可能signalC channel buffer满了，信号丢失

3. **周期切换导致loop退出**：
   - 从日志看，周期重置了3次
   - 可能每次周期切换都会重启loop
   - 导致step函数调用次数少

### 解决方案

1. **检查loop启动逻辑**：
   - 确认loop是否正常启动
   - 检查tickC是否正常发送
   - 确认周期切换时loop是否正常重启

2. **增加signalC buffer大小**：
   - 当前buffer：10
   - 建议增加到100或更大
   - 避免信号丢失

3. **增加日志**：
   - 在loop启动时记录日志
   - 在tick触发时记录日志
   - 在signalC触发时记录日志

---

## 🔍 问题2：持仓更新逻辑

### 现象
- **Trade创建**：2次
- **持仓读取**：0次
- **持仓值**：UP=0.00 DOWN=0.00

### 代码逻辑分析

**Trade创建流程**：
```go
// order_engine.go:830-869
if order.Status == domain.OrderStatusFilled && e.dryRun {
    // 创建Trade对象
    trade := &domain.Trade{...}
    // 发送ProcessTradeCommand
    e.SubmitCommand(tradeCmd)
}
```

**持仓更新流程**：
```go
// order_engine.go:882-964
func (e *OrderEngine) handleProcessTrade(cmd *ProcessTradeCommand) {
    // ...
    // 4. 更新仓位
    e.updatePositionFromTrade(trade, order)
    // ...
}
```

**持仓更新实现**：
```go
// order_engine.go:1057-1134
func (e *OrderEngine) updatePositionFromTrade(trade *domain.Trade, order *domain.Order) {
    // 查找或创建仓位
    positionID := e.getPositionID(order)
    if pos, exists := e.positions[positionID]; exists {
        position = pos
    } else {
        // 创建新仓位
        position = &domain.Position{...}
        e.positions[positionID] = position
    }
    
    // 更新仓位大小
    if trade.Side == types.SideBuy {
        position.Size += trade.Size
    } else {
        position.Size -= trade.Size
    }
}
```

**持仓读取**：
```go
// strategy.go:1406-1420
func (s *Strategy) currentShares(marketSlug string) (up float64, down float64) {
    positions := s.TradingService.GetOpenPositionsForMarket(marketSlug)
    for _, p := range positions {
        if p == nil || !p.IsOpen() || p.Size <= 0 {
            continue
        }
        switch p.TokenType {
        case domain.TokenTypeUp:
            up += p.Size
        case domain.TokenTypeDown:
            down += p.Size
        }
    }
    return up, down
}
```

### 问题分析

**可能原因**：
1. **持仓更新正常，但读取时机不对**：
   - Trade已创建（2次）
   - 持仓应该已更新
   - 但step函数调用次数少（3次），所以currentShares()没有被调用

2. **持仓更新逻辑可能有问题**：
   - 需要检查updatePositionFromTrade是否正常执行
   - 需要检查positionID是否正确
   - 需要检查TokenType是否正确设置

3. **持仓查询可能有问题**：
   - GetOpenPositionsForMarket可能返回空
   - 或者position的MarketSlug不匹配
   - 或者position的Status不是Open

### 解决方案

1. **检查持仓更新日志**：
   - 在updatePositionFromTrade中添加日志
   - 记录positionID、Size、TokenType等信息
   - 确认持仓是否正常更新

2. **检查持仓查询逻辑**：
   - 在GetOpenPositionsForMarket中添加日志
   - 记录查询条件和返回结果
   - 确认持仓是否正常查询

3. **检查positionID生成逻辑**：
   - 确认getPositionID是否正确
   - 确认MarketSlug、AssetID、TokenType是否匹配
   - 确认持仓是否按预期创建

---

## 🔍 问题3：订单数量偏少

### 现象
- **Quote**：1次
- **模拟下单**：1次
- **需要继续下单**：1次

### 问题分析

**根本原因**：
- Step函数调用次数少（3次）
- 导致下单逻辑执行次数少
- 所以订单数量偏少

**解决方案**：
- 解决step函数调用次数少的问题
- 订单数量自然会增加

---

## 📋 总结

### 核心问题
1. **Step函数调用次数少**：
   - 导致下单逻辑执行次数少
   - 导致持仓读取次数少
   - 导致订单数量偏少

2. **持仓更新可能正常，但读取时机不对**：
   - Trade已创建，持仓应该已更新
   - 但step函数调用次数少，所以持仓没有被读取

### 解决方案优先级

1. **高优先级**：解决step函数调用次数少的问题
   - 检查loop启动逻辑
   - 增加signalC buffer大小
   - 增加日志

2. **中优先级**：检查持仓更新逻辑
   - 添加持仓更新日志
   - 检查positionID生成逻辑
   - 检查持仓查询逻辑

3. **低优先级**：继续观察日志
   - 等待更多数据
   - 观察修复后的效果

---

## 💡 建议

1. **立即修复**：
   - 增加signalC buffer大小（从10增加到100）
   - 在loop启动和tick触发时添加日志
   - 在持仓更新和查询时添加日志

2. **继续观察**：
   - 等待修复后的日志
   - 观察step函数调用频率
   - 观察持仓更新情况

3. **验证修复**：
   - 确认step函数调用频率正常
   - 确认持仓正常更新
   - 确认订单数量增加
