# CycleHedge策略持仓平衡逻辑说明

**重要澄清**: 策略的目标是"锁定利润"，而不是严格的"等量UP+DOWN"

---

## 🎯 核心目标

### 目标达成条件

**策略的目标是确保"无论UP还是DOWN胜出都能盈利"**，而不是严格的1:1比例。

**计算公式**:
```go
// UP胜出的PnL
pnlUpWinUSDC = upShares × $1 - totalCostUSDC

// DOWN胜出的PnL  
pnlDownWinUSDC = downShares × $1 - totalCostUSDC

// 最坏情况PnL（取两者最小值）
worstCasePnLUSDC = min(pnlUpWinUSDC, pnlDownWinUSDC)

// 目标达成条件
if worstCasePnLUSDC >= targetWorst {
    // 停止开仓，持有到结算
    return
}
```

**关键点**:
- ✅ **不要求** `upShares == downShares`
- ✅ **只要求** `worstCasePnLUSDC >= targetWorst`
- ✅ **允许** 两边持仓不等，只要最坏情况仍能盈利

---

## 📊 实际示例

### 示例1: 等量持仓（理想情况）

```
持仓: UP=100 shares, DOWN=100 shares
成本: UP成本=48 USDC, DOWN成本=50 USDC, 总成本=98 USDC

UP胜出: pnlUpWin = 100 - 98 = +2 USDC
DOWN胜出: pnlDownWin = 100 - 98 = +2 USDC
worstCasePnL = min(2, 2) = +2 USDC ✅

结论: 无论哪方胜出都能盈利
```

### 示例2: 不等量持仓（实际允许）

```
持仓: UP=120 shares, DOWN=100 shares
成本: UP成本=57.6 USDC, DOWN成本=50 USDC, 总成本=107.6 USDC

UP胜出: pnlUpWin = 120 - 107.6 = +12.4 USDC
DOWN胜出: pnlDownWin = 100 - 107.6 = -7.6 USDC ❌
worstCasePnL = min(12.4, -7.6) = -7.6 USDC

结论: DOWN胜出会亏损，需要继续建仓或调整
```

### 示例3: 不等量但能锁定利润

```
持仓: UP=110 shares, DOWN=100 shares
成本: UP成本=52.8 USDC, DOWN成本=50 USDC, 总成本=102.8 USDC

UP胜出: pnlUpWin = 110 - 102.8 = +7.2 USDC
DOWN胜出: pnlDownWin = 100 - 102.8 = -2.8 USDC ❌
worstCasePnL = min(7.2, -2.8) = -2.8 USDC

结论: 仍然亏损，需要继续建仓
```

### 示例4: 价格差异导致的不等量（实际场景）

```
假设UP价格更低（更便宜），DOWN价格更高（更贵）

策略可能选择:
- 多买UP（因为更便宜）
- 少买DOWN（因为更贵）
- 只要 worstCasePnL >= targetWorst 即可

例如:
持仓: UP=150 shares @ 0.48, DOWN=100 shares @ 0.50
成本: UP成本=72 USDC, DOWN成本=50 USDC, 总成本=122 USDC

UP胜出: pnlUpWin = 150 - 122 = +28 USDC
DOWN胜出: pnlDownWin = 100 - 122 = -22 USDC ❌
worstCasePnL = min(28, -22) = -22 USDC

结论: 需要继续建仓DOWN，直到worstCasePnL >= targetWorst
```

---

## 🔍 当前实现分析

### 1. 目标检查逻辑 ✅

**代码位置**: `strategy.go:634`

```go
if worstCasePnLUSDC >= targetWorst {
    // 目标达成，停止开仓
    return
}
```

**说明**: ✅ **正确** - 基于`worstCasePnL`判断，不要求严格1:1

### 2. 建仓逻辑 ⚠️

**代码位置**: `strategy.go:998-1000`

```go
// 计算目标shares（基于targetNotional和profit）
targetShares = targetNotional * 100 / costCents

// 计算需要开仓的数量
needUp = max(0, targetShares - upShares)
needDown = max(0, targetShares - downShares)
```

**说明**: ⚠️ **当前实现仍然会尽量让两边达到相同的`targetShares`**

**问题**: 
- 如果UP价格更低，策略可能会选择多买UP、少买DOWN
- 但当前实现仍然会尽量让两边达到相同的`targetShares`
- 这可能导致在某些情况下无法充分利用价格差异

### 3. 裸露处理逻辑 ✅

**代码位置**: `strategy.go:1028-1037`

```go
if unhedged >= MinUnhedgedShares {
    // 当已有裸露时，只允许补齐到对侧，不再扩大总规模
    if upShares > downShares {
        needUp = 0  // 只补DOWN
    } else {
        needDown = 0  // 只补UP
    }
}
```

**说明**: ✅ **正确** - 出现裸露时只补齐缺腿

---

## 💡 策略的实际行为

### 正常建仓阶段

1. **尽量保持1:1**: 策略会尽量让`upShares`和`downShares`达到相同的`targetShares`
2. **价格选择**: 通过`chooseDynamicProfit`选择最优的profit，计算对应的UP/DOWN买价
3. **并发下单**: 同时下UP和DOWN订单，降低单腿成交风险

### 出现价格波动时

1. **单腿成交**: 如果只有一腿成交，会出现裸露
2. **补齐逻辑**: 优先补齐缺腿，而不是继续扩大总规模
3. **目标检查**: 基于`worstCasePnL`判断是否达成目标

### 目标达成时

1. **停止开仓**: 当`worstCasePnLUSDC >= targetWorst`时停止开仓
2. **允许不等量**: 即使`upShares != downShares`，只要`worstCasePnL >= targetWorst`即可
3. **持有到结算**: 不再新增持仓，持有现有持仓到结算

---

## 🎯 您的需求 vs 当前实现

### 您的需求 ✅

> "不定完全等量，只要能锁定利润，也就是说，不论up/down哪方win我们都能赚钱即可"

**这个需求已经在代码中实现了！**

**证据**:
1. ✅ 目标检查基于`worstCasePnL`，不要求严格1:1
2. ✅ 允许两边持仓不等，只要`worstCasePnL >= targetWorst`
3. ✅ 出现价格波动时，会优先补齐缺腿

### 当前实现的限制 ⚠️

**在建仓阶段，策略仍然会尽量保持1:1**:

```go
needUp = max(0, targetShares - upShares)
needDown = max(0, targetShares - downShares)
```

**这意味着**:
- 如果UP价格更低，策略**不会主动**多买UP、少买DOWN
- 策略仍然会尽量让两边达到相同的`targetShares`
- 只有在出现价格波动导致不平衡时，才会基于`worstCasePnL`调整

---

## 🔧 可能的优化方向

### 方案1: 基于价格差异动态调整比例

**思路**: 如果UP价格更低，可以多买UP、少买DOWN，只要`worstCasePnL >= targetWorst`

**实现**:
```go
// 计算最优比例（基于价格差异）
if upPrice < downPrice {
    // UP更便宜，可以多买UP
    // 计算最优比例，使得worstCasePnL >= targetWorst
    optimalUpShares = ...
    optimalDownShares = ...
} else {
    // DOWN更便宜，可以多买DOWN
    optimalUpShares = ...
    optimalDownShares = ...
}

needUp = max(0, optimalUpShares - upShares)
needDown = max(0, optimalDownShares - downShares)
```

### 方案2: 基于worstCasePnL动态调整

**思路**: 持续建仓直到`worstCasePnL >= targetWorst`，不强制1:1

**实现**:
```go
// 持续建仓，优先建价格更低的一边
for worstCasePnLUSDC < targetWorst {
    if upPrice < downPrice {
        // UP更便宜，优先买UP
        needUp = calculateOptimalSize(...)
        needDown = 0
    } else {
        // DOWN更便宜，优先买DOWN
        needUp = 0
        needDown = calculateOptimalSize(...)
    }
    // 下单
    // 重新计算worstCasePnL
}
```

---

## 📝 总结

### 当前实现 ✅

1. **目标检查**: 基于`worstCasePnL`，不要求严格1:1 ✅
2. **建仓阶段**: 尽量保持1:1，但允许价格波动导致不平衡 ⚠️
3. **补齐逻辑**: 出现裸露时优先补齐缺腿 ✅

### 您的需求 ✅

> "不定完全等量，只要能锁定利润"

**这个需求已经在目标检查中实现了！**

**当前行为**:
- ✅ 允许两边持仓不等
- ✅ 只要`worstCasePnL >= targetWorst`就停止开仓
- ⚠️ 但在建仓阶段仍然会尽量保持1:1

### 建议

**如果您希望策略能够更灵活地根据价格差异调整比例**，可以考虑：

1. **保持当前实现**（推荐）:
   - 当前实现已经能够处理价格波动
   - 出现不平衡时会自动补齐
   - 基于`worstCasePnL`判断目标达成

2. **优化建仓逻辑**（可选）:
   - 根据价格差异动态调整UP/DOWN比例
   - 优先建价格更低的一边
   - 只要`worstCasePnL >= targetWorst`即可

---

**文档生成时间**: 2025-12-30  
**策略版本**: CycleHedge v1.0
