# 精简预加载方案

## 设计理念

**精简、高效、够用**：只预加载接下来2个周期，每个周期检查一次，闲时拉取。

## 核心策略

### 1. 预加载范围
- **只预加载接下来2个周期**（本周期之后的下一个、下下个）
- 不预加载太多，节省资源

### 2. 检查频率
- **每个周期检查一次**（15分钟一次）
- 不频繁检查，减少开销

### 3. 拉取时机
- **闲时拉取**：在后台异步拉取，不阻塞主线程
- 发现缺失就拉取，不等待

## 工作流程

```
周期开始（00:00）
   ↓
立即检查：接下来2个周期准备好了吗？
   ├─ 如果缺失 → 后台异步拉取（闲时拉取）
   └─ 如果齐全 → 无需操作
   
周期进行中（00:00 - 15:00）
   ↓
后台预加载在拉取数据（如果之前缺失）
   ↓
15分钟后（00:15）
   ↓
周期切换
   ├─ 从缓存读取下一个周期数据
   └─ < 1 微秒，零延迟！✅
   
同时触发下一次检查
   ↓
检查：接下来2个周期准备好了吗？
   └─ 循环继续...
```

## 代码实现

### 检查频率

```go
// 每个周期（15分钟）检查一次
ticker := time.NewTicker(15 * time.Minute)
```

### 预加载范围

```go
// 只预加载接下来2个周期
slugs := GenerateNext15MinSlugs(2) // 接下来2个周期（30分钟）
```

### 闲时拉取

```go
// 异步预加载（不阻塞）
go func() {
    for _, slug := range missingSlugs {
        // 从API获取（闲时拉取）
        market = fetchFromAPI(slug)
        // 存入缓存
        cache[slug] = market
        // 速率限制（不着急）
        time.Sleep(200 * time.Millisecond)
    }
}()
```

## 优势

### 1. 资源占用少
- **内存**：只缓存2个周期，约 400 字节
- **网络**：每个周期最多2次API调用
- **CPU**：15分钟检查一次，几乎为零

### 2. 逻辑简单
- 不需要复杂的优先级处理
- 不需要提前预热机制
- 代码更清晰，维护更容易

### 3. 性能保证
- **切换时**：数据已在缓存中，< 1 微秒
- **检查时**：只是读缓存，< 1 微秒
- **拉取时**：后台异步，不影响主线程

### 4. 够用
- 2个周期 = 30分钟
- 足够覆盖周期切换的需求
- 即使拉取失败，还有下个周期可以重试

## 时间线示例

```
00:00 - 周期1开始
   ├─ 立即检查：周期2、周期3准备好了吗？
   ├─ 发现缺失 → 后台开始拉取（闲时）
   └─ 主交易继续运行（不受影响）
   
00:05 - 周期1进行中
   ├─ 后台预加载：周期2数据拉取完成 ✅
   └─ 主交易继续运行
   
00:10 - 周期1进行中
   ├─ 后台预加载：周期3数据拉取完成 ✅
   └─ 主交易继续运行
   
00:15 - 周期1结束，切换到周期2
   ├─ 从缓存读取周期2数据
   └─ < 1 微秒，零延迟！✅
   
00:15 - 周期2开始
   ├─ 立即检查：周期3、周期4准备好了吗？
   ├─ 周期3已在缓存 ✅
   ├─ 周期4缺失 → 后台开始拉取
   └─ 主交易继续运行
   
...（循环继续）
```

## 性能对比

| 指标 | 之前（100个周期，1分钟检查） | 现在（2个周期，15分钟检查） |
|------|---------------------------|---------------------------|
| **内存占用** | 20KB（100个周期） | 400字节（2个周期） |
| **检查频率** | 每1分钟 | 每15分钟 |
| **API调用** | 最多100次/周期 | 最多2次/周期 |
| **切换延迟** | < 1 微秒 | < 1 微秒 |
| **资源占用** | 较高 | **极低** ✅ |

## 总结

这个精简方案：

- ✅ **够用**：2个周期足够覆盖切换需求
- ✅ **高效**：资源占用极低
- ✅ **简单**：逻辑清晰，易于维护
- ✅ **可靠**：闲时拉取，不影响主线程
- ✅ **性能**：切换时零延迟

完美平衡了**性能**和**资源占用**！

